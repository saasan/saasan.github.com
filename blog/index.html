<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>ブログ</title>
    <link href='//fonts.googleapis.com/css?family=Orbitron:500' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://saasan.github.io/blog/">
    <link rel="alternate" type="application/rss+xml" title="saasan.github.io" href="https://saasan.github.io/feed.xml" />
    <link rel="apple-touch-icon" href="https://saasan.github.io/img/s2works_favicon.png">
    <script data-ad-client="ca-pub-0141905477316976" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@saasan">
    <meta property="og:url" content="https://saasan.github.io/blog/">
    <meta property="og:title" content="ブログ">
    <meta property="og:description" content="雑記、覚え書き、更新情報など">
    <meta property="og:image" content="https://saasan.github.io/img/s2works_favicon.png">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org/",
        "@type": "Person",
        "name": "saasan",
        "sameAs": [
          "https://twitter.com/saasan",
          "https://github.com/saasan"
        ]
      }
    </script>
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Article",
        "name": "ブログ",
      
        "headline": "雑記、覚え書き、更新情報など",
        "image": "https://saasan.github.io/img/s2works_favicon.png",
        "url": "https://saasan.github.io/blog/",
        "publisher" : {
          "@type": "Person",
          "name": "saasan"
        }
      }
    </script>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <header class="site-header">
      <div class="wrapper">
        <a class="site-title" href="/">saasan.github.io</a>
        <nav class="site-nav">
          <div class="site-nav-contents">
            <ul>
              <li><a href="/blog/">ブログ</a></li>
              <li><a href="/imas/">アイマス</a></li>
              <li><a href="/software/">ソフトウェア</a></li>
              <li><a href="/script/">スクリプト</a></li>
            </ul>
          </div>
        </nav>
      </div>
    </header>
    <div class="page-content">
      <div class="wrapper">
        <div class="post" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/WebPageElement">
          <header class="post-header">
            <h1 class="post-title">ブログ</h1>
          </header>
          <article class="post-content">
            <section>
              <h2><a class="post-link" href="/blog/2020/12/16/%E6%9C%80%E8%BF%91%E7%9F%A5%E3%81%A3%E3%81%9Fbash%E3%81%AE%E4%BE%BF%E5%88%A9%E6%A9%9F%E8%83%BD.html">最近知ったBashの便利機能</a></h2>
              <div class="post-meta">2020-12-16</div>
              <section>
                <h2 id="cd--">cd -</h2>
                <p>一つ前のディレクトリへ戻る。</p>
                <p>pushd / popd で2つのディレクトリを往復することがあったけどこっちのほうが速い。</p>
                <h1 id="ctrl--u-ctrl--y">Ctrl + u, Ctrl + y</h1>
                <p><kbd>Ctrl + u</kbd> でカーソル位置から行頭まで切り取る。
                  <kbd>Ctrl + y</kbd> で切り取ったものを貼り付ける。</p>
                <p><kbd>git commit -m "hoge"</kbd> とか書いたところで <kbd>git add</kbd> してないことに気付いたりとか、
                  コマンド入力中に別のコマンドを先に実行したくなったときに便利。</p>
                <p>ちなみに <kbd>Ctrl + k</kbd> ならカーソル位置から行末まで切り取れる。</p>
              </section>
            </section>
            <section>
              <h2><a class="post-link" href="/blog/2020/11/14/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%83%A1%E3%83%8B%E3%83%A5%E3%83%BC%E3%81%8B%E3%82%89%E6%B6%88%E3%81%88%E3%81%9F-dell-command-update-%E3%82%92%E5%BE%A9%E6%B4%BB%E3%81%95%E3%81%9B%E3%82%8B.html">スタートメニューから消えた Dell Command | Update を復活させる</a></h2>
              <div class="post-meta">2020-11-14</div>
              <section>
                <p>Dell Command | Update を実行したあとにスタートメニューから Dell Command | Update が消えることがある。</p>
                <p>しばらく待っていれば自動で復活することもあれば復活しないこともある。
                  復活しないときは一度アンインストールして
                  <a href="https://www.dell.com/support/article/ja-jp/sln311129/dell-command-update?lang=ja">Dell のサイトからダウンロード</a>
                  したものを入れ直していたが、けっこう手間がかかって面倒だった。
                  そもそもアプリの一覧に残ってるならもっと簡単に復活できるんじゃないか？</p>
                <p>そう思ってスタートメニューだけ復活させる方法がないか調べたら以下の方法で復活できた。</p>
                <ol>
                  <li>管理者権限で PowerShell を起動する。</li>
                  <li>
                    <p>以下のコマンドを実行する。</p>
                    <div class="highlighter-rouge">
                      <div class="highlight">
                        <pre class="highlight"><code>$ManifestPath = (Get-AppxPackage -AllUsers -Name "DellInc.DellCommandUpdate").InstallLocation + "\Appxmanifest.xml"
Add-AppxPackage -Path $ManifestPath -Register -DisableDevelopmentMode
</code></pre>
                      </div>
                          </div>
                  </li>
                </ol>
                <p>※Get-AppxPackage に -AllUsers オプションを付けて実行するのに管理者権限が必要。</p>
                <p>参考 : <a href="https://docs.microsoft.com/ja-jp/powershell/module/appx/add-appxpackage?view=winserver2012r2-ps#example-2">Add-AppxPackage (AppX) | Microsoft Docs</a></p>
              </section>
            </section>
            <section>
              <h2><a class="post-link" href="/blog/2020/07/19/usb-cable-checker-2%E3%81%A7usb-type-c%E3%82%B1%E3%83%BC%E3%83%96%E3%83%AB%E3%81%AE%E6%80%A7%E8%83%BD%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B.html">USB CABLE CHECKER 2 で USB Type-C ケーブルの性能を確認する</a></h2>
              <div class="post-meta">2020-07-19</div>
              <section>
                <p>先日 RAVPower 製 90W USB PD 充電器 RP-PC128 を買いました。
                  同じく RAVPower 製の 61W USB PD 充電器 PR-PC112 を持っていたのですが、
                  65W を要求する Dell 製ノート PC に給電しながら電源を入れると
                  途中で電力が足りない旨メッセージが表示されて起動が一時停止したり、
                  Windows 10 起動後も電力不足の通知が表示されるという状態で煩わしかったためです。</p>
                <p>eMarker 付きのケーブルを持っていなかったので
                  RAMPOW という謎のメーカーの PD 3.0 / USB 3.1 Gen2 対応を謳う USB Type-C ケーブルと
                  Bit Trade One の
                  <a href="https://bit-trade-one.co.jp/adusbcim/">USB CABLE CHECKER 2 (ADUSBCIM)</a>
                  もついでに購入しました。</p>
                <p>RAMPOW は <a href="https://rampow.com/">Web サイト</a> を見ても本社所在地や電話番号等が一切書かれておらず怪しげなメーカーという印象だったため、
                  ケーブルを使用する前に念の為 USB CABLE CHECKER 2 で確認しようという寸法です。
                  (※購入後に気付いたのですが、RAMPOW の
                  <a href="https://www.amazon.co.jp/sp?_encoding=UTF8&amp;seller=A2RPIWYAIJTBUL">Amazon出品者プロフィール</a>
                  に住所と電話番号が書かれていました。中国深センの会社のようです。)</p>
                <iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;t=saasan-22&amp;m=amazon&amp;o=9&amp;p=8&amp;l=as1&amp;IS2=1&amp;detail=1&amp;asins=B0872MGDR2&amp;linkId=fac28b4b22c51e4280bc86287fd8dd0a&amp;bc1=000000&amp;lt1=_blank&amp;fc1=333333&amp;lc1=0066c0&amp;bg1=ffffff&amp;f=ifr"></iframe>
                <iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;t=saasan-22&amp;m=amazon&amp;o=9&amp;p=8&amp;l=as1&amp;IS2=1&amp;detail=1&amp;asins=B0827NDHBQ&amp;linkId=bc50d175b4811fb8739a0a5d77f6be35&amp;bc1=000000&amp;lt1=_blank&amp;fc1=333333&amp;lc1=0066c0&amp;bg1=ffffff&amp;f=ifr"></iframe>
                <iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;t=saasan-22&amp;m=amazon&amp;o=9&amp;p=8&amp;l=as1&amp;IS2=1&amp;detail=1&amp;asins=B07Y8BPVV4&amp;linkId=b4348a77ed22af3503ea6572a01d34e9&amp;bc1=000000&amp;lt1=_blank&amp;fc1=333333&amp;lc1=0066c0&amp;bg1=ffffff&amp;f=ifr"></iframe>
                <h2 id="rampow-製ケーブル-rad03">RAMPOW 製ケーブル RAD03</h2>
                <p>さっそく RAMPOW 製ケーブルを確認してみます。</p>
                <p><a href="/img/blog/2020-07-19/rampow.jpg"><img src="/img/blog/2020-07-19/rampow.jpg" alt="RAMPOW 製ケーブル RAD03" /></a></p>
                <p>USB CABLE CHECKER 2 の表示は以下の通り。</p>
                <pre>GND+VBUS=188mΩ
CC:DOWN1K/E-MARKED
SHELL-GND SHORT(A&amp;B)</pre>
                <p>表示の意味については
                  <a href="https://github.com/bit-trade-one/USBCableChecker2/blob/master/README.md">取扱説明書</a>
                  に記載されています。</p>
                <blockquote>
                  <p>[DOWN1K/E-MARKED]</p>
                  <p>Cプラグ内にGND-VCONN間に接続された1kΩの抵抗器を持ちます。</p>
                  <p>これにより接続先USB機器にEマーカーIC内蔵ケーブルということを通知します。</p>
                </blockquote>
                <blockquote>
                  <p>[SHELL-GND SHORT(SIDE)]</p>
                  <p>プラグシェルがGNDと導通している場合表示されます。()内は導通している側のコネクタがA,Bどちらかを表します。</p>
                  <p>両側のコネクタが導通している場合はA&amp;Bと表示されます。</p>
                  <p>なお、タイプC-Cケーブルでは規格でGNDとシェルが接続されることが定められています。</p>
                </blockquote>
                <p><samp>CC:DOWN1K/E-MARKED</samp> は eMarker 内蔵、
                  <samp>SHELL-GND SHORT(A&amp;B)</samp> は両側のプラグシェルが GND と導通していることを示しています。</p>
                <p>eMarker が内蔵されているため 3A を超える電流が流せます。
                  connection のランプも全点灯しており、PD 3.0 / USB 3.1 Gen2 対応を謳うケーブルとして特に問題なさそうです。</p>
                <h2 id="ravpower-製充電器-rp-pc128-付属ケーブル">RAVPower 製充電器 RP-PC128 付属ケーブル</h2>
                <p>購入時に気付いてなかったのですが、
                  RP-PC128 にも 1.5m の Type-C ケーブルが付属していたためこれも確認してみます。</p>
                <p><a href="/img/blog/2020-07-19/ravpower.jpg"><img src="/img/blog/2020-07-19/ravpower.jpg" alt="RAVPower 製 90W USB PD 充電器 RP-PC128 付属ケーブル" /></a></p>
                <pre>GND+VBUS=170mΩ
CC:DOWN1K/E-MARKED
SHELL-GND SHORT(A&amp;B)</pre>
                <p>eMarker が内蔵されているため 3A を超える電流が流せます。
                  connection のランプは USB 2.0 の部分と CC (Configuration Channel) が点灯しています。
                  USB 2.0 対応の PD ケーブルとして使えるようです。</p>
                <p>電源ケーブルとして使うならこれで十分ですね。
                  <del>RAMPOW のケーブルいらなかったのでは？</del></p>
                <h2 id="lenovo-yoga-book-c930-付属ケーブル">Lenovo Yoga Book C930 付属ケーブル</h2>
                <p>手元にあったほかの USB Type-C ケーブルも確認してみます。</p>
                <p><a href="/img/blog/2020-07-19/lenovo.jpg"><img src="/img/blog/2020-07-19/lenovo.jpg" alt="Lenovo Yoga Book C930 付属ケーブル" /></a></p>
                <pre>GND+VBUS=212mΩ
SHELL-GND SHORT(A&amp;B)</pre>
                <p>eMarker が内蔵されていないため 3A までの電流しか流せません。
                  connection のランプは USB 3.2 が一部点灯しています。</p>
                <p>USB 3.0, 3.1 では TX1/RX1 と TX2/RX2 のどちらかが繋がっていれば良いようです。
                  USB 3.2 Gen 2x2 では TX1, TX2, RX1, RX2 のすべてを使用してより高速な通信を行うため、このケーブルは利用できません。</p>
                <p>SBU (Sideband Use) は USB では使用されず、
                  DisplayPort 出力や Thunderbolt などの Alternate Mode に使われる信号線のようです。</p>
                <p>USB 3.1 対応の PD ケーブルとしては使えそう。</p>
                <h2 id="one-netbook-onemix3s-付属ケーブル">One-Netbook OneMix3S 付属ケーブル</h2>
                <p><a href="/img/blog/2020-07-19/onemix3s.jpg"><img src="/img/blog/2020-07-19/onemix3s.jpg" alt="One-Netbook OneMix3S 付属ケーブル" /></a></p>
                <pre>GND+VBUS=225mΩ</pre>
                <p><samp>SHELL-GND SHORT(A&amp;B)</samp> の表示がない……。
                  規格に従ってないケーブルのようです。
                  これは使わないほうがよさそう。</p>
                <h2 id="まとめ">まとめ</h2>
                <p>RAVPower 製 90W USB PD 充電器 RP-PC128 と RAMPOW 製ケーブル RAD03 の組み合わせで、
                  65W を要求する Dell 製ノート PC が問題なく充電できました。</p>
                <p>RP-PC128 は MacBook 付属の 61W USB-C 充電器と比べて
                  サイズがひと回り小さい (65 x 65 x 32 mm) ため持ち運びやすく、
                  90W の大出力により充電できる機器の幅が広がります。</p>
                <p>また、電力に余裕があるため、BUFFALO の
                  5-in-1 ドッキングステーション LUD-U3-CGD/N
                  を間にはさんでも安定して動作しています
                  (61W 出力の PR-PC112 を使用したときは有線 LAN の通信がブツブツ切れていた)。
                  ケーブル1本で電源、ディスプレイ、有線 LAN、キーボードが繋がるのは便利です。</p>
                <iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;t=saasan-22&amp;m=amazon&amp;o=9&amp;p=8&amp;l=as1&amp;IS2=1&amp;detail=1&amp;asins=B081ZZGWR7&amp;linkId=9a6e62087527f859adc8ac8b19af537f&amp;bc1=000000&amp;lt1=_blank&amp;fc1=333333&amp;lc1=0066c0&amp;bg1=ffffff&amp;f=ifr"></iframe>
                <p>今回購入した RAMPOW 製ケーブルは問題ありませんでしたが、
                  手持ちの OneMix3S 付属ケーブルが規格違反だったのは意外でした。
                  USB Power Delivery では高電圧、大電流が流れるため、
                  ケーブル購入の際は信頼できるメーカーのものを選んだほうがよさそうです。</p>
                <h2 id="参考サイト">参考サイト</h2>
                <ul>
                  <li><a href="https://github.com/bit-trade-one/USBCableChecker2/blob/master/README.md">USBCableChecker2/README.md at master · bit-trade-one/USBCableChecker2</a></li>
                  <li><a href="https://ascii.jp/elem/000/001/848/1848727/">ASCII.jp：USB 4の発表で、USB 3.2はどうなった？ (1/5)</a></li>
                  <li><a href="https://www.4gamer.net/games/999/G999902/20190403022/">USB 3.2とUSB4は従来のUSB規格から何が変わるのか？ 混乱しがちなUSBの最新事情を説明しよう - 4Gamer.net</a></li>
                  <li><a href="https://lab.fujiele.co.jp/articles/8968/">USB Type-Cに置き換える方法 第1話 Type-Cの原理を知る | 組込み技術ラボ</a></li>
                </ul>
              </section>
            </section>
            <section>
              <h2><a class="post-link" href="/blog/2020/06/17/m5stickc-speaker-hat%E3%81%A7esp8266audio%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6mp3%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html">M5StickC + Speaker Hat で ESP8266Audio ライブラリを使用して MP3 ファイルを再生する</a></h2>
              <div class="post-meta">2020-06-17</div>
              <section>
                <p>前回の
                  <a href="/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html">M5StickC + Speaker Hat で SPIFFS から読み込んだ WAV ファイルを再生する</a>
                  では自力で WAV ファイルを読み込んでいましたが、
                  <a href="https://github.com/earlephilhower/ESP8266Audio">ESP8266Audio</a>
                  というライブラリを用いることで ESP32-PICO 搭載の M5StickC でも MP3 が再生できることを教えて頂きました。
                  ということで、今回は事前に SPIFFS へ保存した MP3 ファイルを ESP8266Audio で読み込んで再生します。</p>
                <h2 id="スケッチ">スケッチ</h2>
                <p>以下は A ボタン(正面の「M5」ボタン)を押すと MP3 ファイルが再生されるスケッチです。</p>
                <noscript>
                  <pre>#include &lt;M5StickC.h&gt;
#include &quot;FS.h&quot;
#include &quot;SPIFFS.h&quot;
#include &quot;AudioFileSourceSPIFFS.h&quot;
#include &quot;AudioGeneratorMP3.h&quot;
#include &quot;AudioOutputI2S.h&quot;

// オーディオファイル名
const char AUDIO_FILE_NAME[] = &quot;/hoge.mp3&quot;;

const int I2S_NUM_0 = 0;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

AudioGeneratorMP3 *generator = NULL;
AudioFileSourceSPIFFS *source = NULL;
AudioOutputI2S *output = NULL;

// メッセージ出力
void showMessage(const char *message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 35);
    M5.Lcd.setTextFont(2);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

void playAudio() {
    Serial.println(&quot;playAudio&quot;);

    stopAudio();
    if (!source-&gt;isOpen()) {
        source-&gt;open(AUDIO_FILE_NAME);
    }
    generator-&gt;begin(source, output);
}

void stopAudio() {
    Serial.println(&quot;stopAudio&quot;);

    if (generator-&gt;isRunning()) {
        generator-&gt;stop();
    }
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&quot;ESP8266Audio&quot;);

    // シリアルモニターの設定
    Serial.begin(115200);
    audioLogger = &amp;Serial;

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&quot;SPIFFS Mount Failed&quot;);
        return;
    }

    source = new AudioFileSourceSPIFFS(AUDIO_FILE_NAME);
    output = new AudioOutputI2S(I2S_NUM_0, AudioOutputI2S::INTERNAL_DAC);
    generator = new AudioGeneratorMP3();
}

void loop() {
    delay(10);

    if (generator-&gt;isRunning()) {
        if (!generator-&gt;loop()) {
            stopAudio();
        }
    }
    else {
        // ボタンの状態を更新
        M5.update();

        // Aボタンが押されたら音声データ再生
        if (M5.BtnA.wasPressed()) {
            playAudio();
        }

        // 電源ボタンが押されたらリセット
        if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
            esp_restart();
        }
    }
}
</pre>
                </noscript>
                <script src="https://gist.github.com/saasan/ed2ee155ed1a16865015c1967cf875c3.js"></script>
                <p>SPIFFS からファイルを読み込む AudioFileSourceSPIFFS クラス、
                  MP3 を再生する AudioGeneratorMP3 クラス、
                  I2S で出力する AudioOutputI2S クラスを使用しています。
                  ESP8266Audio は MP3 以外にも WAV, FLAC, MIDI, AAC などのファイル形式を読み込めるようになっており、
                  それぞれのファイル形式に対応した generator クラスを使用する必要があります。</p>
                <p>generator-&gt;isRunning() で再生中か確認し、再生中でない場合にボタンが押されたら MP3 ファイルを再生しています。
                  一度再生が終わり generator-&gt;stop() を呼び出すとファイルが閉じられます。
                  そのため、2回目以降の再生時はファイルを再び開く必要があります。
                  source-&gt;isOpen() でファイルが開かれているかを確認し、
                  開かれていない場合は source-&gt;open() でファイルを開いています。</p>
                <p>AudioFileSourceSPIFFS クラスでは再生する度にファイルを読み込むため、
                  ESP32-PICO のメモリ (520KB) に収まるサイズのファイルを何度も再生するのであれば、
                  以下のように setup() 内でファイルを読み込み
                  AudioFileSourcePROGMEM クラスを使用した方がよいかと思います。</p>
                <noscript>
                  <pre>#include &lt;M5StickC.h&gt;
#include &quot;FS.h&quot;
#include &quot;SPIFFS.h&quot;
#include &quot;AudioFileSourcePROGMEM.h&quot;
#include &quot;AudioGeneratorMP3.h&quot;
#include &quot;AudioOutputI2S.h&quot;

// オーディオファイル名
const char AUDIO_FILE_NAME[] = &quot;/hoge.mp3&quot;;

const int I2S_NUM_0 = 0;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

AudioGeneratorMP3 *generator = NULL;
AudioFileSourcePROGMEM *source = NULL;
AudioOutputI2S *output = NULL;
uint8_t *audioData = NULL;
size_t audioDataSize = 0;

// メッセージ出力
void showMessage(const char *message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 35);
    M5.Lcd.setTextFont(2);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

void readAudioFile(fs::FS&amp; fs, const char* path) {
    File file = fs.open(path);
    if (!file || file.isDirectory()) {
        Serial.println(&quot;- failed to open file for reading&quot;);
        return;
    }

    audioDataSize = file.size();
    audioData = new uint8_t[audioDataSize];
    file.read(audioData, audioDataSize);
}

void playAudio() {
    Serial.println(&quot;playAudio&quot;);

    stopAudio();
    if (!source-&gt;isOpen()) {
        source-&gt;open(audioData, audioDataSize);
    }
    generator-&gt;begin(source, output);
}

void stopAudio() {
    Serial.println(&quot;stopAudio&quot;);

    if (generator-&gt;isRunning()) {
        generator-&gt;stop();
    }
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&quot;ESP8266Audio&quot;);

    // シリアルモニターの設定
    Serial.begin(115200);
    audioLogger = &amp;Serial;

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&quot;SPIFFS Mount Failed&quot;);
        return;
    }

    readAudioFile(SPIFFS, AUDIO_FILE_NAME);

    source = new AudioFileSourcePROGMEM(audioData, audioDataSize);
    output = new AudioOutputI2S(I2S_NUM_0, AudioOutputI2S::INTERNAL_DAC);
    generator = new AudioGeneratorMP3();
}

void loop() {
    delay(10);

    if (generator-&gt;isRunning()) {
        if (!generator-&gt;loop()) {
            stopAudio();
        }
    }
    else {
        // ボタンの状態を更新
        M5.update();

        // Aボタンが押されたら音声データ再生
        if (M5.BtnA.wasPressed()) {
            playAudio();
        }

        // 電源ボタンが押されたらリセット
        if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
            esp_restart();
        }
    }
}
</pre>
                </noscript>
                <script src="https://gist.github.com/saasan/b6d9cb8fc8786d9c0407560f6206af22.js"></script>
                <h2 id="自力での-wav-ファイル再生との比較">自力での WAV ファイル再生との比較</h2>
                <p>前回行った自力での WAV ファイル再生では 8bit, 8000Hz 限定だったこともあり、
                  比較すると音質はかなり改善しましたが、
                  再生の前後にプチプチとノイズが入るようになりました。
                  また、コンパイルにかかる時間もかなり長くなっています。</p>
                <p>コンパイル時間はどうしようもないと思いますが、
                  再生前後のプチプチは下記参考サイトのクリックノイズ対策を行えば消せるかもしれません。</p>
                <h2 id="参考サイト">参考サイト</h2>
                <ul>
                  <li><a href="https://github.com/earlephilhower/ESP8266Audio">earlephilhower/ESP8266Audio: Arduino library to play MOD, WAV, FLAC, MIDI, RTTTL, MP3, and AAC files on I2S DACs or with a software emulated delta-sigma DAC on the ESP8266 and ESP32</a></li>
                  <li><a href="https://qiita.com/odetarou/items/0f37ed2eeeb9bd051c0c">ESP32でGoogle Play Musicを再生する - Qiita</a></li>
                  <li><a href="http://blog-yama.a-quest.com/?eid=970190">ESP32でサウンド出力時のクリックノイズ対策（I2S+内蔵DAC） | N.Yamazaki’s blog</a></li>
                </ul>
              </section>
            </section>
            <section>
              <h2><a class="post-link" href="/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html">M5StickC + Speaker Hat で SPIFFS から読み込んだ WAV ファイルを再生する</a></h2>
              <div class="post-meta">2020-06-07</div>
              <section>
                <p>前回の
                  <a href="/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html">M5StickC + Speaker Hat で音声データを再生する</a>
                  では音声データを直接スケッチ上に書くというスマートとは言い難い方法でした。
                  今回は事前に SPIFFS へ保存した WAV ファイルを読み込んで再生します。</p>
                <h2 id="wav-ファイルの作成">WAV ファイルの作成</h2>
                <p>まずは再生したい音声データを以下の形式の WAV ファイルへ変換します。</p>
                <ul>
                  <li>モノラル</li>
                  <li>サンプリング周波数8000Hz</li>
                  <li>Unsigned 8-bit PCM</li>
                  <li>メタデータなし</li>
                </ul>
                <p>スピーカーが1つなのでモノラル、
                  M5StickC (というか ESP32) の DAC が 8 ビットなので WAV ファイルも 8 ビットです。
                  サンプリング周波数は 8000Hz じゃなくてもいいかもしれませんが、
                  一般的に使用されている 44100Hz ではうまく動作しなかったためこの値にしています。</p>
                <p>また、今回のスケッチではメタデータを一切考慮していないため、
                  メタデータがあるとシリアルモニタへ “invalid wave file header”
                  というエラーメッセージが表示されファイルが読み込まれません。</p>
                <p>以下は
                  <a href="https://ffmpeg.org/">FFmpeg</a>
                  で変換する場合のコマンド例です。
                  FFmpeg で変換すると「Lavf58.29.100」(数字部分はバージョンによる)
                  というメタデータが標準で追加されるので、
                  オプション <kbd>-fflags +bitexact</kbd> を付けてこの動作を抑制します。</p>
                <div class="highlighter-rouge">
                  <div class="highlight">
                    <pre class="highlight"><code>ffmpeg -i input.wav -ac 1 -ar 8000 -acodec pcm_u8 -fflags +bitexact output.wav
</code></pre>
                  </div>
                </div>
                <h2 id="wav-ファイルを-spiffs-へ保存する">WAV ファイルを SPIFFS へ保存する</h2>
                <p><a href="https://www.mgo-tec.com/blog-entry-spiffs-uploader-plugin-arduino-esp32.html">ESP32-WROOM-32 SPIFFS アップローダープラグインの使い方 | mgo-tec電子工作</a>
                  に書かれている手順に従い、
                  <a href="https://github.com/me-no-dev/arduino-esp32fs-plugin">Arduino ESP32 filesystem uploader</a>
                  を使用して事前に  WAV ファイルを SPIFFS へ保存しておきます。</p>
                <h2 id="スケッチの書き込み">スケッチの書き込み</h2>
                <p>以下のスケッチを M5StickC へ書き込みます。
                  WAVE_FILE_NAME は SPIFFS へ保存した  WAV ファイルのファイル名です。
                  書き込み後、Aボタン(正面の「M5」ボタン)を押すと WAV ファイルが再生されます。</p>
                <noscript>
                  <pre>#include &lt;vector&gt;
#include &lt;M5StickC.h&gt;
#include &quot;FS.h&quot;
#include &quot;SPIFFS.h&quot;

// WAVファイル名
const char WAVE_FILE_NAME[] = &quot;/hoge.wav&quot;;

// スピーカー出力ピンの番号
const uint8_t SPEAKER_PIN = GPIO_NUM_26;
// LOWでLED点灯、HIGHでLED消灯
const uint8_t LED_ON = LOW;
const uint8_t LED_OFF = HIGH;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

// PWM出力のチャンネル
const uint8_t PWM_CHANNEL = 0;
// PWM出力の分解能(ビット数)
const uint8_t PWM_RESOLUTION = 8;
// PWM出力の周波数
const uint32_t PWM_FREQUENCY = getApbFrequency() / (1U &lt;&lt; PWM_RESOLUTION);
// 音声データのサンプリング周波数(Hz)
const uint32_t SOUND_SAMPLING_RATE = 8000;
// 音声データ再生時の待ち時間(マイクロ秒)
const uint32_t DELAY_INTERVAL = 1000000 / SOUND_SAMPLING_RATE;

// WAVファイルのヘッダー
typedef struct {
    uint32_t riff;              // &quot;RIFF&quot; (0x52494646)
    uint32_t fileSize;          // ファイルサイズ-8
    uint32_t wave;              // &quot;WAVE&quot; (0x57415645)
    uint32_t fmt;               // &quot;fmt &quot; (0x666D7420)
    uint32_t fmtSize;           // fmtチャンクのバイト数
    uint16_t format;            // 音声フォーマット (非圧縮リニアPCMは1)
    uint16_t channels;          // チャンネル数
    uint32_t samplingRate;      // サンプリングレート
    uint32_t avgBytesPerSecond; // 1秒あたりのバイト数の平均
    uint16_t blockAlign;        // ブロックサイズ
    uint16_t bitsPerSample;     // 1サンプルあたりのビット数
    uint32_t data;              // &quot;data&quot; (0x64617461)
    uint32_t dataSize;          // 波形データのバイト数
} wavfileheader_t;
// PCMフォーマット
const uint16_t WAVE_FORMAT_PCM = 0x0001;
// モノラル
const uint16_t WAVE_MONAURAL = 0x0001;

// 音声データ
std::vector&lt;uint8_t&gt; soundData;


// メッセージ出力
void showMessage(const char* message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 30);
    M5.Lcd.setTextFont(4);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

// バイトオーダーを入れ替える
uint32_t reverseByteOrder(uint32_t x) {
    return ((x &lt;&lt; 24 &amp; 0xFF000000U) |
            (x &lt;&lt;  8 &amp; 0x00FF0000U) |
            (x &gt;&gt;  8 &amp; 0x0000FF00U) |
            (x &gt;&gt; 24 &amp; 0x000000FFU));
}

// WAVファイルのヘッダーを検証する
bool validateWavHeader(wavfileheader_t&amp; header) {
    Serial.printf(&quot;riff: 0x%x\n&quot;, header.riff);
    Serial.printf(&quot;wave: 0x%x\n&quot;, header.wave);
    Serial.printf(&quot;fmt : 0x%x\n&quot;, header.fmt);
    Serial.printf(&quot;data: 0x%x\n&quot;, header.data);
    Serial.printf(&quot;format: %d\n&quot;, header.format);
    Serial.printf(&quot;channels: %d\n&quot;, header.channels);
    Serial.printf(&quot;samplingRate: %d\n&quot;, header.samplingRate);
    Serial.printf(&quot;bitsPerSample: %d\n&quot;, header.bitsPerSample);

    return  header.riff             == 0x52494646
            &amp;&amp; header.wave          == 0x57415645
            &amp;&amp; header.fmt           == 0x666D7420
            &amp;&amp; header.data          == 0x64617461
            &amp;&amp; header.format        == WAVE_FORMAT_PCM
            &amp;&amp; header.channels      == WAVE_MONAURAL
            &amp;&amp; header.samplingRate  == SOUND_SAMPLING_RATE
            &amp;&amp; header.bitsPerSample == PWM_RESOLUTION;
}

// WAVファイルを読み込む
void readWavFile(fs::FS&amp; fs, const char* path, std::vector&lt;uint8_t&gt;&amp; data) {
    Serial.printf(&quot;Reading file: %s\n&quot;, path);

    File file = fs.open(path);
    if (!file || file.isDirectory()) {
        Serial.println(&quot;- failed to open file for reading&quot;);
        return;
    }

    // WAVファイルのヘッダー
    wavfileheader_t header;

    // ファイルサイズがヘッダーサイズ以下の場合は終了
    size_t fileSize = file.size();
    if (fileSize &lt;= sizeof(header)) {
        Serial.println(&quot;invalid wave file&quot;);
        return;
    }

    // ヘッダーサイズ分読み込む
    file.read((uint8_t*)&amp;header, sizeof(header));

    // バイトオーダーを入れ替え
    header.riff = reverseByteOrder(header.riff);
    header.wave = reverseByteOrder(header.wave);
    header.fmt  = reverseByteOrder(header.fmt);
    header.data = reverseByteOrder(header.data);

    // ヘッダーのチェック
    if (!validateWavHeader(header)) {
        Serial.println(&quot;invalid wave file header&quot;);
        return;
    }

    // ファイルの読み込み
    while (file.available()) {
        data.push_back(file.read());
    }
}

// 音声データを再生する
void playSound(std::vector&lt;uint8_t&gt;&amp; soundData) {
    for (const auto&amp; level : soundData) {
        ledcWrite(PWM_CHANNEL, level);
        delayMicroseconds(DELAY_INTERVAL);
    }

    ledcWrite(PWM_CHANNEL, 0);
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&quot;SPIFFS WAV&quot;);

    // シリアルモニターの設定
    Serial.begin(115200);

    // スピーカーの設定
    ledcSetup(PWM_CHANNEL, PWM_FREQUENCY, PWM_RESOLUTION);
    ledcAttachPin(SPEAKER_PIN, PWM_CHANNEL);
    ledcWrite(PWM_CHANNEL, 0);

    // LEDの設定
    pinMode(M5_LED, OUTPUT);
    digitalWrite(M5_LED, LED_OFF);

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&quot;SPIFFS Mount Failed&quot;);
        return;
    }

    // 音声データを読み込む
    readWavFile(SPIFFS, WAVE_FILE_NAME, soundData);
}

void loop() {
    delay(10);

    // ボタンの状態を更新
    M5.update();

    // Aボタンが押されたら音声データ再生
    if (M5.BtnA.wasPressed()) {
        // LED点灯
        digitalWrite(M5_LED, LED_ON);
        // 音声データ再生
        playSound(soundData);
        // LED消灯
        digitalWrite(M5_LED, LED_OFF);
    }

    // 電源ボタンが押されたらリセット
    if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
        esp_restart();
    }
}
</pre>
                </noscript>
                <script src="https://gist.github.com/saasan/f03a6569138715d7d46a33e7a4d06e19.js"></script>
                <h2 id="参考サイト">参考サイト</h2>
                <ul>
                  <li><a href="https://www.mgo-tec.com/blog-entry-spiffs-uploader-plugin-arduino-esp32.html">ESP32-WROOM-32 SPIFFS アップローダープラグインの使い方 | mgo-tec電子工作</a></li>
                  <li><a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/SPIFFS/examples/SPIFFS_Test/SPIFFS_Test.ino">arduino-esp32/SPIFFS_Test.ino at master · espressif/arduino-esp32</a></li>
                  <li><a href="https://www.youfit.co.jp/archives/1418">音ファイル（拡張子：WAVファイル）のデータ構造について</a></li>
                  <li><a href="https://yatt.hatenablog.jp/entry/20090904/1252078381">リニアPCMのWAVファイルを読み込む - yattのブログ</a></li>
                </ul>
              </section>
            </section>
            <div class="pagination">
              <span>&laquo; 前のページ</span>
              <em>1</em>
              <a href="/blog/page2/">2</a>
              <a href="/blog/page3/">3</a>
              <a href="/blog/page2/">次のページ &raquo;</a>
            </div>
          </article>
        </div>
      </div>
    </div>
    <footer class="site-footer">
      <div class="wrapper">
        <nav>
          <ul>
            <li><a href="/blog/">ブログ</a></li>
            <li><a href="/imas/">アイマス</a></li>
            <li><a href="/software/">ソフトウェア</a></li>
            <li><a href="/script/">スクリプト</a></li>
          </ul>
          <a href="https://twitter.com/saasan" target="_blank" class="twitter-username">
            saasan
          </a>
          <a href="/feed.xml" target="_blank" class="rss">RSS</a>
        </nav>
      </div>
    </footer>
  </body>
</html>