<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>saasan.github.io</title>
    <description></description>
    <link>https://saasan.github.io/</link>
    <atom:link href="https://saasan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 17 Jun 2020 23:46:42 +0900</pubDate>
    <lastBuildDate>Wed, 17 Jun 2020 23:46:42 +0900</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>M5StickC + Speaker Hat で ESP8266Audio ライブラリを使用して MP3 ファイルを再生する</title>
        <description>&lt;p&gt;前回の
&lt;a href=&quot;/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html&quot;&gt;M5StickC + Speaker Hat で SPIFFS から読み込んだ WAV ファイルを再生する&lt;/a&gt;
では自力で WAV ファイルを読み込んでいましたが、
&lt;a href=&quot;https://github.com/earlephilhower/ESP8266Audio&quot;&gt;ESP8266Audio&lt;/a&gt;
というライブラリを用いることで ESP32-PICO 搭載の M5StickC でも MP3 が再生できることを教えて頂きました。
ということで、今回は事前に SPIFFS へ保存した MP3 ファイルを ESP8266Audio で読み込んで再生します。&lt;/p&gt;

&lt;h2 id=&quot;スケッチ&quot;&gt;スケッチ&lt;/h2&gt;

&lt;p&gt;以下は A ボタン(正面の「M5」ボタン)を押すと MP3 ファイルが再生されるスケッチです。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;quot;FS.h&amp;quot;
#include &amp;quot;SPIFFS.h&amp;quot;
#include &amp;quot;AudioFileSourceSPIFFS.h&amp;quot;
#include &amp;quot;AudioGeneratorMP3.h&amp;quot;
#include &amp;quot;AudioOutputI2S.h&amp;quot;

// オーディオファイル名
const char AUDIO_FILE_NAME[] = &amp;quot;/hoge.mp3&amp;quot;;

const int I2S_NUM_0 = 0;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

AudioGeneratorMP3 *generator = NULL;
AudioFileSourceSPIFFS *source = NULL;
AudioOutputI2S *output = NULL;

// メッセージ出力
void showMessage(const char *message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 35);
    M5.Lcd.setTextFont(2);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

void playAudio() {
    Serial.println(&amp;quot;playAudio&amp;quot;);

    stopAudio();
    if (!source-&amp;gt;isOpen()) {
        source-&amp;gt;open(AUDIO_FILE_NAME);
    }
    generator-&amp;gt;begin(source, output);
}

void stopAudio() {
    Serial.println(&amp;quot;stopAudio&amp;quot;);

    if (generator-&amp;gt;isRunning()) {
        generator-&amp;gt;stop();
    }
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;ESP8266Audio&amp;quot;);

    // シリアルモニターの設定
    Serial.begin(115200);
    audioLogger = &amp;amp;Serial;

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&amp;quot;SPIFFS Mount Failed&amp;quot;);
        return;
    }

    source = new AudioFileSourceSPIFFS(AUDIO_FILE_NAME);
    output = new AudioOutputI2S(I2S_NUM_0, AudioOutputI2S::INTERNAL_DAC);
    generator = new AudioGeneratorMP3();
}

void loop() {
    delay(10);

    if (generator-&amp;gt;isRunning()) {
        if (!generator-&amp;gt;loop()) {
            stopAudio();
        }
    }
    else {
        // ボタンの状態を更新
        M5.update();

        // Aボタンが押されたら音声データ再生
        if (M5.BtnA.wasPressed()) {
            playAudio();
        }

        // 電源ボタンが押されたらリセット
        if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
            esp_restart();
        }
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/ed2ee155ed1a16865015c1967cf875c3.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;SPIFFS からファイルを読み込む AudioFileSourceSPIFFS クラス、
MP3 を再生する AudioGeneratorMP3 クラス、
I2S で出力する AudioOutputI2S クラスを使用しています。
ESP8266Audio は MP3 以外にも WAV, FLAC, MIDI, AAC などのファイル形式を読み込めるようになっており、
それぞれのファイル形式に対応した generator クラスを使用する必要があります。&lt;/p&gt;

&lt;p&gt;generator-&amp;gt;isRunning() で再生中か確認し、再生中でない場合にボタンが押されたら MP3 ファイルを再生しています。
一度再生が終わり generator-&amp;gt;stop() を呼び出すとファイルが閉じられます。
そのため、2回目以降の再生時はファイルを再び開く必要があります。
source-&amp;gt;isOpen() でファイルが開かれているかを確認し、
開かれていない場合は source-&amp;gt;open() でファイルを開いています。&lt;/p&gt;

&lt;p&gt;AudioFileSourceSPIFFS クラスでは再生する度にファイルを読み込むため、
ESP32-PICO のメモリ (520KB) に収まるサイズのファイルを何度も再生するのであれば、
以下のように setup() 内でファイルを読み込み
AudioFileSourcePROGMEM クラスを使用した方がよいかと思います。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;quot;FS.h&amp;quot;
#include &amp;quot;SPIFFS.h&amp;quot;
#include &amp;quot;AudioFileSourcePROGMEM.h&amp;quot;
#include &amp;quot;AudioGeneratorMP3.h&amp;quot;
#include &amp;quot;AudioOutputI2S.h&amp;quot;

// オーディオファイル名
const char AUDIO_FILE_NAME[] = &amp;quot;/hoge.mp3&amp;quot;;

const int I2S_NUM_0 = 0;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

AudioGeneratorMP3 *generator = NULL;
AudioFileSourcePROGMEM *source = NULL;
AudioOutputI2S *output = NULL;
uint8_t *audioData = NULL;
size_t audioDataSize = 0;

// メッセージ出力
void showMessage(const char *message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 35);
    M5.Lcd.setTextFont(2);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

void readAudioFile(fs::FS&amp;amp; fs, const char* path) {
    File file = fs.open(path);
    if (!file || file.isDirectory()) {
        Serial.println(&amp;quot;- failed to open file for reading&amp;quot;);
        return;
    }

    audioDataSize = file.size();
    audioData = new uint8_t[audioDataSize];
    file.read(audioData, audioDataSize);
}

void playAudio() {
    Serial.println(&amp;quot;playAudio&amp;quot;);

    stopAudio();
    if (!source-&amp;gt;isOpen()) {
        source-&amp;gt;open(audioData, audioDataSize);
    }
    generator-&amp;gt;begin(source, output);
}

void stopAudio() {
    Serial.println(&amp;quot;stopAudio&amp;quot;);

    if (generator-&amp;gt;isRunning()) {
        generator-&amp;gt;stop();
    }
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;ESP8266Audio&amp;quot;);

    // シリアルモニターの設定
    Serial.begin(115200);
    audioLogger = &amp;amp;Serial;

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&amp;quot;SPIFFS Mount Failed&amp;quot;);
        return;
    }

    readAudioFile(SPIFFS, AUDIO_FILE_NAME);

    source = new AudioFileSourcePROGMEM(audioData, audioDataSize);
    output = new AudioOutputI2S(I2S_NUM_0, AudioOutputI2S::INTERNAL_DAC);
    generator = new AudioGeneratorMP3();
}

void loop() {
    delay(10);

    if (generator-&amp;gt;isRunning()) {
        if (!generator-&amp;gt;loop()) {
            stopAudio();
        }
    }
    else {
        // ボタンの状態を更新
        M5.update();

        // Aボタンが押されたら音声データ再生
        if (M5.BtnA.wasPressed()) {
            playAudio();
        }

        // 電源ボタンが押されたらリセット
        if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
            esp_restart();
        }
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/b6d9cb8fc8786d9c0407560f6206af22.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;自力での-wav-ファイル再生との比較&quot;&gt;自力での WAV ファイル再生との比較&lt;/h2&gt;

&lt;p&gt;前回行った自力での WAV ファイル再生では 8bit, 8000Hz 限定だったこともあり、
比較すると音質はかなり改善しましたが、
再生の前後にプチプチとノイズが入るようになりました。
また、コンパイルにかかる時間もかなり長くなっています。&lt;/p&gt;

&lt;p&gt;コンパイル時間はどうしようもないと思いますが、
再生前後のプチプチは下記参考サイトのクリックノイズ対策を行えば消せるかもしれません。&lt;/p&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/earlephilhower/ESP8266Audio&quot;&gt;earlephilhower/ESP8266Audio: Arduino library to play MOD, WAV, FLAC, MIDI, RTTTL, MP3, and AAC files on I2S DACs or with a software emulated delta-sigma DAC on the ESP8266 and ESP32&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/odetarou/items/0f37ed2eeeb9bd051c0c&quot;&gt;ESP32でGoogle Play Musicを再生する - Qiita&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog-yama.a-quest.com/?eid=970190&quot;&gt;ESP32でサウンド出力時のクリックノイズ対策（I2S+内蔵DAC） | N.Yamazaki’s blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 17 Jun 2020 19:59:34 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/06/17/m5stickc-speaker-hat%E3%81%A7esp8266audio%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6mp3%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/06/17/m5stickc-speaker-hat%E3%81%A7esp8266audio%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6mp3%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC,</category>
        
        <category>M5Stack,</category>
        
        <category>ESP32</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC + Speaker Hat で SPIFFS から読み込んだ WAV ファイルを再生する</title>
        <description>&lt;p&gt;前回の
&lt;a href=&quot;/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html&quot;&gt;M5StickC + Speaker Hat で音声データを再生する&lt;/a&gt;
では音声データを直接スケッチ上に書くというスマートとは言い難い方法でした。
今回は事前に SPIFFS へ保存した WAV ファイルを読み込んで再生します。&lt;/p&gt;

&lt;h2 id=&quot;wav-ファイルの作成&quot;&gt;WAV ファイルの作成&lt;/h2&gt;

&lt;p&gt;まずは再生したい音声データを以下の形式の WAV ファイルへ変換します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;モノラル&lt;/li&gt;
  &lt;li&gt;サンプリング周波数8000Hz&lt;/li&gt;
  &lt;li&gt;Unsigned 8-bit PCM&lt;/li&gt;
  &lt;li&gt;メタデータなし&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スピーカーが1つなのでモノラル、
M5StickC (というか ESP32) の DAC が 8 ビットなので WAV ファイルも 8 ビットです。
サンプリング周波数は 8000Hz じゃなくてもいいかもしれませんが、
一般的に使用されている 44100Hz ではうまく動作しなかったためこの値にしています。&lt;/p&gt;

&lt;p&gt;また、今回のスケッチではメタデータを一切考慮していないため、
メタデータがあるとシリアルモニタへ “invalid wave file header”
というエラーメッセージが表示されファイルが読み込まれません。&lt;/p&gt;

&lt;p&gt;以下は
&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;FFmpeg&lt;/a&gt;
で変換する場合のコマンド例です。
FFmpeg で変換すると「Lavf58.29.100」(数字部分はバージョンによる)
というメタデータが標準で追加されるので、
オプション &lt;kbd&gt;-fflags +bitexact&lt;/kbd&gt; を付けてこの動作を抑制します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -i input.wav -ac 1 -ar 8000 -acodec pcm_u8 -fflags +bitexact output.wav
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wav-ファイルを-spiffs-へ保存する&quot;&gt;WAV ファイルを SPIFFS へ保存する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.mgo-tec.com/blog-entry-spiffs-uploader-plugin-arduino-esp32.html&quot;&gt;ESP32-WROOM-32 SPIFFS アップローダープラグインの使い方 | mgo-tec電子工作&lt;/a&gt;
に書かれている手順に従い、
&lt;a href=&quot;https://github.com/me-no-dev/arduino-esp32fs-plugin&quot;&gt;Arduino ESP32 filesystem uploader&lt;/a&gt;
を使用して事前に  WAV ファイルを SPIFFS へ保存しておきます。&lt;/p&gt;

&lt;h2 id=&quot;スケッチの書き込み&quot;&gt;スケッチの書き込み&lt;/h2&gt;

&lt;p&gt;以下のスケッチを M5StickC へ書き込みます。
WAVE_FILE_NAME は SPIFFS へ保存した  WAV ファイルのファイル名です。
書き込み後、Aボタン(正面の「M5」ボタン)を押すと WAV ファイルが再生されます。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;quot;FS.h&amp;quot;
#include &amp;quot;SPIFFS.h&amp;quot;

// WAVファイル名
const char WAVE_FILE_NAME[] = &amp;quot;/hoge.wav&amp;quot;;

// スピーカー出力ピンの番号
const uint8_t SPEAKER_PIN = GPIO_NUM_26;
// LOWでLED点灯、HIGHでLED消灯
const uint8_t LED_ON = LOW;
const uint8_t LED_OFF = HIGH;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

// PWM出力のチャンネル
const uint8_t PWM_CHANNEL = 0;
// PWM出力の分解能(ビット数)
const uint8_t PWM_RESOLUTION = 8;
// PWM出力の周波数
const uint32_t PWM_FREQUENCY = getApbFrequency() / (1U &amp;lt;&amp;lt; PWM_RESOLUTION);
// 音声データのサンプリング周波数(Hz)
const uint32_t SOUND_SAMPLING_RATE = 8000;
// 音声データ再生時の待ち時間(マイクロ秒)
const uint32_t DELAY_INTERVAL = 1000000 / SOUND_SAMPLING_RATE;

// WAVファイルのヘッダー
typedef struct {
    uint32_t riff;              // &amp;quot;RIFF&amp;quot; (0x52494646)
    uint32_t fileSize;          // ファイルサイズ-8
    uint32_t wave;              // &amp;quot;WAVE&amp;quot; (0x57415645)
    uint32_t fmt;               // &amp;quot;fmt &amp;quot; (0x666D7420)
    uint32_t fmtSize;           // fmtチャンクのバイト数
    uint16_t format;            // 音声フォーマット (非圧縮リニアPCMは1)
    uint16_t channels;          // チャンネル数
    uint32_t samplingRate;      // サンプリングレート
    uint32_t avgBytesPerSecond; // 1秒あたりのバイト数の平均
    uint16_t blockAlign;        // ブロックサイズ
    uint16_t bitsPerSample;     // 1サンプルあたりのビット数
    uint32_t data;              // &amp;quot;data&amp;quot; (0x64617461)
    uint32_t dataSize;          // 波形データのバイト数
} wavfileheader_t;
// PCMフォーマット
const uint16_t WAVE_FORMAT_PCM = 0x0001;
// モノラル
const uint16_t WAVE_MONAURAL = 0x0001;

// 音声データ
std::vector&amp;lt;uint8_t&amp;gt; soundData;


// メッセージ出力
void showMessage(const char* message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 30);
    M5.Lcd.setTextFont(4);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

// バイトオーダーを入れ替える
uint32_t reverseByteOrder(uint32_t x) {
    return ((x &amp;lt;&amp;lt; 24 &amp;amp; 0xFF000000U) |
            (x &amp;lt;&amp;lt;  8 &amp;amp; 0x00FF0000U) |
            (x &amp;gt;&amp;gt;  8 &amp;amp; 0x0000FF00U) |
            (x &amp;gt;&amp;gt; 24 &amp;amp; 0x000000FFU));
}

// WAVファイルのヘッダーを検証する
bool validateWavHeader(wavfileheader_t&amp;amp; header) {
    Serial.printf(&amp;quot;riff: 0x%x\n&amp;quot;, header.riff);
    Serial.printf(&amp;quot;wave: 0x%x\n&amp;quot;, header.wave);
    Serial.printf(&amp;quot;fmt : 0x%x\n&amp;quot;, header.fmt);
    Serial.printf(&amp;quot;data: 0x%x\n&amp;quot;, header.data);
    Serial.printf(&amp;quot;format: %d\n&amp;quot;, header.format);
    Serial.printf(&amp;quot;channels: %d\n&amp;quot;, header.channels);
    Serial.printf(&amp;quot;samplingRate: %d\n&amp;quot;, header.samplingRate);
    Serial.printf(&amp;quot;bitsPerSample: %d\n&amp;quot;, header.bitsPerSample);

    return  header.riff             == 0x52494646
            &amp;amp;&amp;amp; header.wave          == 0x57415645
            &amp;amp;&amp;amp; header.fmt           == 0x666D7420
            &amp;amp;&amp;amp; header.data          == 0x64617461
            &amp;amp;&amp;amp; header.format        == WAVE_FORMAT_PCM
            &amp;amp;&amp;amp; header.channels      == WAVE_MONAURAL
            &amp;amp;&amp;amp; header.samplingRate  == SOUND_SAMPLING_RATE
            &amp;amp;&amp;amp; header.bitsPerSample == PWM_RESOLUTION;
}

// WAVファイルを読み込む
void readWavFile(fs::FS&amp;amp; fs, const char* path, std::vector&amp;lt;uint8_t&amp;gt;&amp;amp; data) {
    Serial.printf(&amp;quot;Reading file: %s\n&amp;quot;, path);

    File file = fs.open(path);
    if (!file || file.isDirectory()) {
        Serial.println(&amp;quot;- failed to open file for reading&amp;quot;);
        return;
    }

    // WAVファイルのヘッダー
    wavfileheader_t header;

    // ファイルサイズがヘッダーサイズ以下の場合は終了
    size_t fileSize = file.size();
    if (fileSize &amp;lt;= sizeof(header)) {
        Serial.println(&amp;quot;invalid wave file&amp;quot;);
        return;
    }

    // ヘッダーサイズ分読み込む
    file.read((uint8_t*)&amp;amp;header, sizeof(header));

    // バイトオーダーを入れ替え
    header.riff = reverseByteOrder(header.riff);
    header.wave = reverseByteOrder(header.wave);
    header.fmt  = reverseByteOrder(header.fmt);
    header.data = reverseByteOrder(header.data);

    // ヘッダーのチェック
    if (!validateWavHeader(header)) {
        Serial.println(&amp;quot;invalid wave file header&amp;quot;);
        return;
    }

    // ファイルの読み込み
    while (file.available()) {
        data.push_back(file.read());
    }
}

// 音声データを再生する
void playSound(std::vector&amp;lt;uint8_t&amp;gt;&amp;amp; soundData) {
    for (const auto&amp;amp; level : soundData) {
        ledcWrite(PWM_CHANNEL, level);
        delayMicroseconds(DELAY_INTERVAL);
    }

    ledcWrite(PWM_CHANNEL, 0);
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;SPIFFS WAV&amp;quot;);

    // シリアルモニターの設定
    Serial.begin(115200);

    // スピーカーの設定
    ledcSetup(PWM_CHANNEL, PWM_FREQUENCY, PWM_RESOLUTION);
    ledcAttachPin(SPEAKER_PIN, PWM_CHANNEL);
    ledcWrite(PWM_CHANNEL, 0);

    // LEDの設定
    pinMode(M5_LED, OUTPUT);
    digitalWrite(M5_LED, LED_OFF);

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&amp;quot;SPIFFS Mount Failed&amp;quot;);
        return;
    }

    // 音声データを読み込む
    readWavFile(SPIFFS, WAVE_FILE_NAME, soundData);
}

void loop() {
    delay(10);

    // ボタンの状態を更新
    M5.update();

    // Aボタンが押されたら音声データ再生
    if (M5.BtnA.wasPressed()) {
        // LED点灯
        digitalWrite(M5_LED, LED_ON);
        // 音声データ再生
        playSound(soundData);
        // LED消灯
        digitalWrite(M5_LED, LED_OFF);
    }

    // 電源ボタンが押されたらリセット
    if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
        esp_restart();
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/f03a6569138715d7d46a33e7a4d06e19.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mgo-tec.com/blog-entry-spiffs-uploader-plugin-arduino-esp32.html&quot;&gt;ESP32-WROOM-32 SPIFFS アップローダープラグインの使い方 | mgo-tec電子工作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/espressif/arduino-esp32/blob/master/libraries/SPIFFS/examples/SPIFFS_Test/SPIFFS_Test.ino&quot;&gt;arduino-esp32/SPIFFS_Test.ino at master · espressif/arduino-esp32&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youfit.co.jp/archives/1418&quot;&gt;音ファイル（拡張子：WAVファイル）のデータ構造について&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yatt.hatenablog.jp/entry/20090904/1252078381&quot;&gt;リニアPCMのWAVファイルを読み込む - yattのブログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 07 Jun 2020 20:24:56 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC,</category>
        
        <category>M5Stack,</category>
        
        <category>ESP32</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC + Speaker Hat で音声データを再生する</title>
        <description>&lt;p&gt;M5StickC + Speaker Hat で音声や音楽を再生しようと思ったら
意外と情報が見つからなかったので再生方法をメモしておきます。&lt;/p&gt;

&lt;h2 id=&quot;音声データの変換&quot;&gt;音声データの変換&lt;/h2&gt;

&lt;p&gt;まずは WAV や MP3 など再生したい音声データを
&lt;a href=&quot;http://nn-hokuson.hatenablog.com/entry/2017/09/01/092945&quot;&gt;【Arduino】WAVまたはMP3ファイルを再生する - おもちゃラボ&lt;/a&gt;
に書かれている方法で以下の形式へ変換します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;モノラル&lt;/li&gt;
  &lt;li&gt;サンプリング周波数8000Hz&lt;/li&gt;
  &lt;li&gt;Unsigned 8-bit PCM&lt;/li&gt;
  &lt;li&gt;ヘッダなし&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;配列化&quot;&gt;配列化&lt;/h2&gt;

&lt;p&gt;その後C言語の配列に変換する必要がありますが、
Windows 環境では xxd コマンドがないため
&lt;a href=&quot;https://hello-world.blog.ss-blog.jp/2016-10-16&quot;&gt;バイナリファイルをC言語のデータ配列に変換する：放課後マイコンクラブ：SSブログ&lt;/a&gt;
の「PROGMEM作蔵さん」を使用して変換しました。&lt;/p&gt;

&lt;h2 id=&quot;スケッチへ貼り付けて書き込み&quot;&gt;スケッチへ貼り付けて書き込み&lt;/h2&gt;

&lt;p&gt;配列ができたら以下のスケッチの SOUND_DATA 部分に貼り付け、M5StickC へ書き込みます。
Aボタン(正面の「M5」ボタン)を押すと音声データが再生されます。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;M5StickC.h&amp;gt;

// スピーカー出力ピンの番号
const uint8_t SPEAKER_PIN = GPIO_NUM_26;
// LOWでLED点灯、HIGHでLED消灯
const uint8_t LED_ON = LOW;
const uint8_t LED_OFF = HIGH;

// PWM出力のチャンネル
const uint8_t PWM_CHANNEL = 0;
// PWM出力の分解能
const uint8_t PWM_RESOLUTION = 8;
// PWM出力の周波数
const uint32_t PWM_FREQUENCY = getApbFrequency() / (1U &amp;lt;&amp;lt; PWM_RESOLUTION);
// 音声データのサンプリング周波数(Hz)
const uint32_t SOUND_SAMPLING_RATE = 8000U;

// 音声データ
const uint8_t SOUND_DATA[] PROGMEM = {
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, …
};

// メッセージ出力
void showMessage(char *message) {
    M5.Lcd.fillScreen(TFT_BLACK);
    M5.Lcd.setCursor(5, 30);
    M5.Lcd.setTextFont(4);
    M5.Lcd.print(message);
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;Sound&amp;quot;);

    // スピーカーの設定
    ledcSetup(PWM_CHANNEL, PWM_FREQUENCY, PWM_RESOLUTION);
    ledcAttachPin(SPEAKER_PIN, PWM_CHANNEL);
    ledcWrite(PWM_CHANNEL, 0);

    // LEDの設定
    pinMode(M5_LED, OUTPUT);
    digitalWrite(M5_LED, LED_OFF);
}

void playMusic(const uint8_t* music_data, uint32_t sample_rate) {
    uint32_t length = strlen((char*)music_data);
    uint32_t delay_interval = ((uint32_t)1000000U / sample_rate);
    for (int i = 0; i &amp;lt; length; i++) {
        ledcWrite(PWM_CHANNEL, music_data[i]);
        delayMicroseconds(delay_interval);
    }
    ledcWrite(PWM_CHANNEL, 0);
}

void loop() {
    delay(10U);

    // ボタンの状態を更新
    M5.update();

    // ボタンが押された場合の処理
    if (M5.BtnA.wasPressed())
    {
        // LED点灯
        digitalWrite(M5_LED, LED_ON);
        // 音声データ再生
        playMusic(SOUND_DATA, SOUND_SAMPLING_RATE);
        // LED消灯
        digitalWrite(M5_LED, LED_OFF);
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/5ae9fc7ede308cd513e9769c4335c94f.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;playMusic 関数は公式の
&lt;a href=&quot;https://github.com/m5stack/M5StickC/blob/master/examples/Hat/SPEAKER/SPEAKER.ino&quot;&gt;サンプルスケッチ&lt;/a&gt;
のものですが、
そのままでは音声が正常に再生されなかったため
ledcWriteTone から ledcWrite へ変更しています。
(公式のサンプルスケッチが間違ってるとは思わなかったのでここでハマった。)&lt;/p&gt;

&lt;p&gt;今回は短い音声の再生だったためスケッチにそのまま配列として書きましたが、
音声データ部分だけで500行を超えましたし、
配列への変換も面倒なのでファイルから読み込むようにしたいですね。
&lt;a href=&quot;https://lang-ship.com/reference/unofficial/M5StickC/Storage/SPIFFS/&quot;&gt;SPIFFS&lt;/a&gt;
を使えば実現できそう。&lt;/p&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/m5stack/M5StickC/blob/master/examples/Hat/SPEAKER/SPEAKER.ino&quot;&gt;M5StickC/SPEAKER.ino at master · m5stack/M5StickC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nn-hokuson.hatenablog.com/entry/2017/09/01/092945&quot;&gt;【Arduino】WAVまたはMP3ファイルを再生する - おもちゃラボ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hello-world.blog.ss-blog.jp/2016-10-16&quot;&gt;バイナリファイルをC言語のデータ配列に変換する：放課後マイコンクラブ：SSブログ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://lang-ship.com/blog/work/esp32-pwm-max/&quot;&gt;ESP32のPWM出力は255が最大じゃなかった – Lang-ship&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wisdom.sakura.ne.jp/system/winapi/media/mm5.html&quot;&gt;PCM の基本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 May 2020 10:59:30 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC,</category>
        
        <category>M5Stack,</category>
        
        <category>ESP32</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>RedHat5.7からCentOS5.7へ移行する</title>
        <description>&lt;p&gt;RHEL 5.7 の物理サーバをクローンして仮想化する際、ライセンス的に問題がありそうなので CentOS 5.7 へ移行した話。&lt;/p&gt;

&lt;h2 id=&quot;公式ドキュメント&quot;&gt;公式ドキュメント&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.centos.org/HowTos/MigrationGuide#head-c31a6a29f59a74d75074d1b110f563ffc15cb86a&quot;&gt;Migration an existing system from RHEL5 to CentOS 5&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;実際の作業&quot;&gt;実際の作業&lt;/h2&gt;

&lt;p&gt;基本的に上記公式ドキュメントのコマンド通り。
パッケージのダウンロード元サーバが変更になっているのと、OS のバージョン、CPU アーキテクチャが違うので手直ししている。CPU アーキテクチャは uname -a で確認できる。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -O http://vault.centos.org/5.7/os/x86_64/CentOS/centos-release-5-7.el5.centos.x86_64.rpm
$ curl -O http://vault.centos.org/5.7/os/x86_64/CentOS/centos-release-notes-5.7-0.x86_64.rpm
$ curl -O http://vault.centos.org/5.7/os/x86_64/CentOS/redhat-logos-4.9.99-11.el5.centos.noarch.rpm
$ su
# cp /etc/redhat-release /etc/redhat-release-saved
# rpm -e --nodeps redhat-release-notes redhat-release yum-rhn-plugin redhat-logos
# rpm -ivh centos-release-5-7.el5.centos.x86_64.rpm centos-release-notes-5.7-0.x86_64.rpm redhat-logos-4.9.99-11.el5.centos.noarch.rpm
# yum update
Loaded plugins: product-id, security, subscription-manager
Updating Red Hat repositories.
YumRepo Error: All mirror URLs are not using ftp, http[s] or file.
Eg. Invalid release/
removing mirrorlist with no valid mirrors: /var/cache/yum/base/mirrorlist.txt
Error: Cannot retrieve repository metadata (repomd.xml) for repository: base. Please verify its path and try again
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;yum update でエラーが出るので /etc/yum.repos.d/CentOS-Base.repo を編集。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mirrorlistをコメントアウト&lt;/li&gt;
  &lt;li&gt;#baseurl=http://mirror.centos.org/centos/$releasever/ を baseurl=http://vault.centos.org/5.7/ へ変更&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再度 yum update したら完了。&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 19:47:52 +0900</pubDate>
        <link>https://saasan.github.io/blog/2017/07/31/redhat5.7%E3%81%8B%E3%82%89centos5.7%E3%81%B8%E7%A7%BB%E8%A1%8C%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2017/07/31/redhat5.7%E3%81%8B%E3%82%89centos5.7%E3%81%B8%E7%A7%BB%E8%A1%8C%E3%81%99%E3%82%8B.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>コマンドライン(CLI)でFortiGateを設定する</title>
        <description>&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;FortiGateはブラウザーでアクセスすることでWeb上からGUIで設定できる。
しかし、諸事情によりコマンドラインから設定することになったので、設定方法をメモしておく。&lt;/p&gt;

&lt;h2 id=&quot;ログインする&quot;&gt;ログインする&lt;/h2&gt;

&lt;p&gt;sshで接続することでコマンドラインから設定ができる。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh admin@192.168.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ヘルプを表示する&quot;&gt;ヘルプを表示する&lt;/h2&gt;

&lt;p&gt;「?」を入力すると現在使えるコマンドが表示される。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ? ←「?」を入力しても表示されない
config      config object
get         get dynamic and system information
show        show configuration
diagnose    diagnose facility
execute     execute static commands
exit        exit CLI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;コマンドの入力途中に「?」を入力するとコマンドが補完される。
例えば、sh?と入力するとshowに補完される。&lt;/p&gt;

&lt;p&gt;また、引数が必要なコマンドを入力した後に「?」を入力すると引数の候補が表示される。&lt;/p&gt;

&lt;h2 id=&quot;バージョンを確認する&quot;&gt;バージョンを確認する&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# get system status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;設定を確認する&quot;&gt;設定を確認する&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# show
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;デフォルト値を含むすべての設定を確認する&quot;&gt;デフォルト値を含むすべての設定を確認する&lt;/h2&gt;

&lt;p&gt;数メガバイトある設定が出力される為、かなり時間がかかるので注意。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# show full-configuration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;moreを使用しない&quot;&gt;moreを使用しない&lt;/h1&gt;

&lt;p&gt;コンソールへ設定を出力してバックアップを取りたいような場合は、
下記のコマンドでmoreを表示しないようにすることができる。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;moreを使用しないように変更&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# config system console
# set output standard
# end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;moreを使用するように戻す&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# config system console
# set output more
# end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;設定を変更する&quot;&gt;設定を変更する&lt;/h2&gt;

&lt;p&gt;上記「設定を確認する」や「デフォルト値を含むすべての設定を確認する」で
表示されたものを見れば分かるが、設定はディレクトリのように階層化されている。
また、表示されたものがほぼそのまま設定用のコマンドになっている。&lt;/p&gt;

&lt;p&gt;基本的に、&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;コマンド「config ○○○」で設定を行いたい階層に移動&lt;/li&gt;
  &lt;li&gt;コマンド「set △△△ ×××」で値を設定&lt;/li&gt;
  &lt;li&gt;コマンド「end」で設定を完了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という流れで設定する。上記「moreを使用しない」を参照。&lt;/p&gt;

&lt;h2 id=&quot;設定を保存する&quot;&gt;設定を保存する&lt;/h2&gt;

&lt;p&gt;設定は自動的に保存される。
Cisco製品のように「write memory」などで明示的に保存する必要はない。&lt;/p&gt;

&lt;h2 id=&quot;設定を終了し切断する&quot;&gt;設定を終了し切断する&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 03 May 2017 00:18:36 +0900</pubDate>
        <link>https://saasan.github.io/blog/2017/05/03/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3-CLI-%E3%81%A7FortiGate%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2017/05/03/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3-CLI-%E3%81%A7FortiGate%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Visual Studio Code で Markdown のプレビューを保存する</title>
        <description>&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;Visual Studio Code の Markdown プレビューは
なかなか見栄えが良くて気に入ってる。
そのまま保存してドキュメントとして使いたいが、
今のところ (2017/01/14、バージョン1.8.1) プレビューを保存する機能は
ないようなので、同等のものを生成するスクリプトを作成した。&lt;/p&gt;

&lt;p&gt;ネットを検索するといくつか同様のことを行うものが見つかったが、
Markdown エンジンの違いにより VSCode と出力結果が異なる
(リスト内のテーブルなど)
ものばかりだった。
このスクリプトは VSCode と同じ
&lt;a href=&quot;https://github.com/markdown-it/markdown-it&quot;&gt;markdown-it&lt;/a&gt;
を使用し、出力結果が同じになるようにしている。&lt;/p&gt;

&lt;h2 id=&quot;動作に必要なもの&quot;&gt;動作に必要なもの&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://nodejs.org/ja/&quot;&gt;Node.js&lt;/a&gt; が必要&lt;/p&gt;

&lt;h2 id=&quot;使い方&quot;&gt;使い方&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;このリポジトリをローカルにクローンする&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt; する&lt;/li&gt;
  &lt;li&gt;同じフォルダにHTML化したい Markdown ファイルを入れる&lt;/li&gt;
  &lt;li&gt;フォルダを Visual Studio Code で開く&lt;/li&gt;
  &lt;li&gt;gulpfile.js を編集し、HTML のタイトルなどを設定する&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl + Shift + B&lt;/code&gt; を押してビルドする&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ビルドが終わるとできる dest フォルダに markdown.css を入れる&lt;/p&gt;

    &lt;p&gt;※ markdown.css は
VS Codeをインストールしたフォルダの
resources\app\extensions\markdown\media\markdown.css
にあります。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ダウンロード&quot;&gt;ダウンロード&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/saasan/save-vscode-markdown-preview&quot;&gt;GitHub&lt;/a&gt;
からダウンロードできます。&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Jan 2017 22:15:58 +0900</pubDate>
        <link>https://saasan.github.io/blog/2017/01/14/save-vscode-markdown-preview.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2017/01/14/save-vscode-markdown-preview.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>バッチファイルでミリ秒単位のSleepを行う</title>
        <description>&lt;p&gt;最近の Windows だと timeout コマンドを使えば秒単位で Sleep (Wait) できるがミリ秒単位ではできない。
そこで Windows PowerShell を使って以下のようにミリ秒単位で Sleep する。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;@ECHO OFF

ECHO &amp;quot;500ミリ秒寝ます&amp;quot;
powershell -Command &amp;quot;sleep -m 500&amp;quot;
ECHO &amp;quot;起きました&amp;quot;

PAUSE
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/a7e7368a7450ed4dd0a9e5e73bd77060.js&quot;&gt; &lt;/script&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 20:23:15 +0900</pubDate>
        <link>https://saasan.github.io/blog/2016/08/02/%E3%83%90%E3%83%83%E3%83%81%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%83%9F%E3%83%AA%E7%A7%92%E5%8D%98%E4%BD%8D%E3%81%AEsleep%E3%82%92%E8%A1%8C%E3%81%86.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2016/08/02/%E3%83%90%E3%83%83%E3%83%81%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%83%9F%E3%83%AA%E7%A7%92%E5%8D%98%E4%BD%8D%E3%81%AEsleep%E3%82%92%E8%A1%8C%E3%81%86.html</guid>
        
        <category>バッチファイル</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>[Jekyll] ビルドするときにだけSass(SCSS)を圧縮する</title>
        <description>&lt;p&gt;_config.yml に Sass(SCSS) を圧縮する設定を書くと、常時圧縮がかかってしまう。
これでは、ブラウザで表示を確認しながら CSS をいじるとき困る。
ということで、製作中は圧縮せずにビルド時だけ圧縮する方法。&lt;/p&gt;

&lt;p&gt;&lt;small&gt;※ 2016/3/4現在、 Jekyll では Sourcemap が出力できないっぽい。&lt;/small&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-ビルド用設定ファイルを作る&quot;&gt;1. ビルド用設定ファイルを作る&lt;/h3&gt;

&lt;p&gt;_config.yml と同じフォルダに
_config-production.yml という名前のファイルを作成し、以下の通り書く&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sass:
  style: compressed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考: 
&lt;a href=&quot;https://jekyllrb.com/docs/assets/#sassscss&quot; target=&quot;_blank&quot;&gt;Assets - Jekyll • Simple, blog-aware, static sites&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-製作時のコマンド&quot;&gt;2. 製作時のコマンド&lt;/h3&gt;

&lt;p&gt;製作中はいつも通り。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-ビルド時のコマンド&quot;&gt;3. ビルド時のコマンド&lt;/h3&gt;

&lt;p&gt;ビルドするときは –config オプションで _config.yml と _config-production.yml の2つを読み込む。
両方のファイルに同じ設定項目がある場合は、後ろに書いた方の設定で上書きされる。
カンマとファイル名の間にスペースを入れないこと。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build --config _config.yml,_config-production.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考: 
&lt;a href=&quot;https://jekyllrb.com/docs/configuration/#build-command-options&quot; target=&quot;_blank&quot;&gt;Configuration - Jekyll • Simple, blog-aware, static sites&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 19:19:37 +0900</pubDate>
        <link>https://saasan.github.io/blog/2016/03/04/jekyll-%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AB%E3%81%A0%E3%81%91sass-scss-%E3%82%92%E5%9C%A7%E7%B8%AE%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2016/03/04/jekyll-%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AB%E3%81%A0%E3%81%91sass-scss-%E3%82%92%E5%9C%A7%E7%B8%AE%E3%81%99%E3%82%8B.html</guid>
        
        <category>Jekyll</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Google AdSenseの確定申告</title>
        <description>&lt;p&gt;Google AdSenseでの収入が年間20万円を超えると、サラリーマンやアルバイトなど本業で源泉徴収されている人でも確定申告しなきゃいけないらしい。&lt;/p&gt;

&lt;p&gt;参考 :
&lt;a href=&quot;https://www.nta.go.jp/taxanswer/shotoku/1900.htm&quot; target=&quot;_blank&quot;&gt;No.1900 給与所得者で確定申告が必要な人｜所得税｜国税庁&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ありがたいことに、うちも売上が20万円を超えて確定申告することになったのでメモ。&lt;/p&gt;

&lt;h3 id=&quot;確定申告に必要なもの&quot;&gt;確定申告に必要なもの&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;生命保険料控除証明書など (いつも年末調整で提出してるやつ)&lt;/li&gt;
  &lt;li&gt;本業の会社からもらった源泉徴収票&lt;/li&gt;
  &lt;li&gt;パソコン&lt;/li&gt;
  &lt;li&gt;プリンター
または &lt;a href=&quot;https://www.printing.ne.jp/&quot; target=&quot;_blank&quot;&gt;ネットプリント&lt;/a&gt; などのコンビニで印刷できるサービス&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;申告書を作る&quot;&gt;申告書を作る&lt;/h3&gt;

&lt;p&gt;国税庁のホームページに
&lt;a href=&quot;https://www.keisan.nta.go.jp/h27/ta_top.htm&quot; target=&quot;_blank&quot;&gt;確定申告書等作成コーナー&lt;/a&gt;
があるのでそこで作る。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;「書面提出」 &amp;gt; 「所得税コーナー」 &amp;gt; 「左記以外の所得のある方(全ての所得対応)」&lt;/li&gt;
  &lt;li&gt;「給与所得」に源泉徴収票通り入力&lt;/li&gt;
  &lt;li&gt;「雑所得」の「その他」に以下の通り入力
    &lt;ul&gt;
      &lt;li&gt;種目 : 広告収入&lt;/li&gt;
      &lt;li&gt;報酬などの支払者の氏名・名称 : &lt;del&gt;グーグル株式会社&lt;/del&gt; グーグル合同会社 (2018/03/04 修正)&lt;/li&gt;
      &lt;li&gt;所得の生ずる場所 : 東京都港区六本木６丁目１０－１ 六本木ヒルズ森タワー&lt;/li&gt;
      &lt;li&gt;収入金額 : AdSenseでの収入金額&lt;br /&gt;
(&lt;a href=&quot;https://www.google.com/adsense/app#main/home&quot; target=&quot;_blank&quot;&gt;AdSenseのサイト&lt;/a&gt;
        &lt;blockquote&gt;
          &lt;p&gt;「残高」右上の「…」 &amp;gt; 「お支払いページを表示」 &amp;gt; 「取引」右下の「取引を表示する」 &amp;gt; 上部のフィルターを「詳細取引表示」、「お支払い」、「前年」にして金額を合計する)&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;あとは控除など必要がある場合は入力&lt;/li&gt;
  &lt;li&gt;最後にPDFファイルがダウンロードできるので、これをプリンターかネットプリントなどで印刷&lt;/li&gt;
  &lt;li&gt;印刷した申告書に捺印と署名を行い、添付書類を貼り付ける&lt;/li&gt;
  &lt;li&gt;印刷した紙に書かれている提出先税務署へ郵送する&lt;br /&gt;
(普通郵便でもいいが送った記録が残らないので、万全を期すなら
&lt;a href=&quot;https://www.post.japanpost.jp/service/fuka_service/tokutei_kiroku/&quot; target=&quot;_blank&quot;&gt;特定記録&lt;/a&gt;
や
&lt;a href=&quot;https://www.post.japanpost.jp/service/fuka_service/kakitome/&quot; target=&quot;_blank&quot;&gt;書留&lt;/a&gt;
で)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;その他&quot;&gt;その他&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AdSenseでの収入を証明する書類は必要はない&lt;/strong&gt; そうな (申告内容が不審で税務調査されない限りは)。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;所得税の確定申告をすれば自動で各市町村に連絡が行き住民税に反映される&lt;/strong&gt; ので住民税の申告は必要ない。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 18:08:47 +0900</pubDate>
        <link>https://saasan.github.io/blog/2016/02/19/Google-AdSense%E3%81%AE%E7%A2%BA%E5%AE%9A%E7%94%B3%E5%91%8A.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2016/02/19/Google-AdSense%E3%81%AE%E7%A2%BA%E5%AE%9A%E7%94%B3%E5%91%8A.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>[Jekyll] Liquidのタグをエスケープする方法</title>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{% raw %}&lt;/code&gt; と &lt;code class=&quot;highlighter-rouge&quot;&gt;{% endraw %}&lt;/code&gt; で囲むと
Liquidのタグもそのまま出力されます。&lt;/p&gt;

&lt;p&gt;例えば&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;{% raw %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  {% for post in site.posts %}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ post.url }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{{ post.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  {% endfor %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
{% endraw %}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;と書いた場合の出力は以下のようになります。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  {% for post in site.posts %}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ post.url }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{{ post.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  {% endfor %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Tue, 15 Dec 2015 19:13:07 +0900</pubDate>
        <link>https://saasan.github.io/blog/2015/12/15/jekyll-escape-liquid-tags.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2015/12/15/jekyll-escape-liquid-tags.html</guid>
        
        <category>Jekyll</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
