<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>saasan.github.io</title>
    <description></description>
    <link>https://saasan.github.io/</link>
    <atom:link href="https://saasan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 09 Jun 2021 00:43:31 +0900</pubDate>
    <lastBuildDate>Wed, 09 Jun 2021 00:43:31 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Slack へ通知するシェルスクリプト</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://qiita.com/piroor/items/77233173707a0baa6360&quot;&gt;プログラマーの君！ 騙されるな！ シェルスクリプトはそう書いちゃ駄目だ！！ という話 - Qiita&lt;/a&gt;
を読み、シェルスクリプトで関数へ値を渡す際は
引数よりも標準入出力を使ったほうがシンプルに書けるようだったので、
以前書いた Slack へ通知メッセージを送るスクリプトを書き直してみた。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#!/bin/bash

WEBHOOK_URL=https://hooks.slack.com/services/xxxxxxxxxxx/xxxxxxxxxxx/xxxxxxxxxxxxxxxxxxxxxxxx

post_slack() {
    echo &amp;quot;payload={\&amp;quot;text\&amp;quot;: \&amp;quot;$(cat)\&amp;quot;}&amp;quot; | curl -s -S -X POST -d @- ${WEBHOOK_URL}
}

echo &amp;quot;&amp;lt;!here&amp;gt;\nhoge\nfuga&amp;quot; | post_slack
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/cbca2f81a3d39ea6dfa85ada5460cf33.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;post_slack では以下のかたちで処理している。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cat で標準入力から取り込んだ文字列を echo で結合し JSON を作成する。&lt;/li&gt;
  &lt;li&gt;それをパイプで curl へ渡す。&lt;/li&gt;
  &lt;li&gt;curl では &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d @-&lt;/code&gt; で標準入力から取り込んだ文字列を POST する。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;標準入出力をパイプで繋ぐかたちとすることで、
以前は10行あった post_slack が3行に短縮された。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 May 2021 23:59:43 +0900</pubDate>
        <link>https://saasan.github.io/blog/2021/05/20/slack%E3%81%B8%E9%80%9A%E7%9F%A5%E3%81%99%E3%82%8B%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2021/05/20/slack%E3%81%B8%E9%80%9A%E7%9F%A5%E3%81%99%E3%82%8B%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88.html</guid>
        
        <category>Linux</category>
        
        <category>Bash</category>
        
        <category>シェルスクリプト</category>
        
        <category>Slack</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC でキーボード操作を自動化する</title>
        <description>&lt;p&gt;某ゲームでアイテムを交換する作業が面倒になってきたので
キーボード操作を自動化したいと思った。&lt;/p&gt;

&lt;p&gt;まず思いついたのは、手元にあった
&lt;a href=&quot;https://www.amazon.co.jp/dp/B004INFZEG/saasan-22&quot;&gt;サンワサプライ製のプログラマブルテンキー NT-19UH2BK&lt;/a&gt;。
久しぶりに引っぱりだして確認したところ、これは &lt;kbd&gt;Ctrl + C&lt;/kbd&gt; のような同時押しには対応しているが、
ウェイトをはさみながら複数のキーを順次入力する用途には対応していなかった。&lt;/p&gt;

&lt;p&gt;次に &lt;a href=&quot;https://booth.pm/ja/items/2655838&quot;&gt;AZ-Macro&lt;/a&gt;
というマクロ機能のある自作 Bluetooth キーボードキットがあることを思い出した。
これは ESP32 で作られていて、
&lt;a href=&quot;https://github.com/palette-system/az-macro&quot;&gt;ファームウェアのソースコードも公開&lt;/a&gt;
されている。
手持ちの M5StickC なら同じ ESP32 が内蔵されており
Bluetooth にも対応しているため、目的を実現できるのではないか？&lt;/p&gt;

&lt;p&gt;ということで、M5StickC を Bluetooth キーボードとして PC へ接続し操作を自動化する。&lt;/p&gt;

&lt;h2 id=&quot;arduino-ide-へ-esp32-ble-keyboard-をインストール&quot;&gt;Arduino IDE へ ESP32-BLE-Keyboard をインストール&lt;/h2&gt;

&lt;p&gt;まずは M5StickC を Bluetooth キーボードとして使うためのライブラリを
Arduino IDE へインストールする。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/T-vK/ESP32-BLE-Keyboard/releases&quot;&gt;Releases · T-vK/ESP32-BLE-Keyboard&lt;/a&gt;
から ESP32-BLE-Keyboard.zip をダウンロード&lt;/li&gt;
  &lt;li&gt;Arduino IDE のメニューで [スケッチ] - [ライブラリをインクルード] - [.ZIP形式のライブラリをインストール…] をクリック&lt;/li&gt;
  &lt;li&gt;さきほどダウンロードした ESP32-BLE-Keyboard.zip を選択&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;esp32-ble-keyboard-の使い方&quot;&gt;ESP32-BLE-Keyboard の使い方&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/T-vK/ESP32-BLE-Keyboard/blob/master/examples/SendKeyStrokes/SendKeyStrokes.ino&quot;&gt;公式のサンプル&lt;/a&gt;
を見れば大まかな使い方はわかると思うが、メソッドの説明がないので補足しておく。&lt;/p&gt;

&lt;p&gt;BleKeyboard クラスの以下のメソッドでキーを操作できる。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;print: 文字列を入力&lt;/li&gt;
  &lt;li&gt;write: キーを押してすぐに離す&lt;/li&gt;
  &lt;li&gt;press: キーを押す (release するまで押したままにする)&lt;/li&gt;
  &lt;li&gt;release: キーを離す&lt;/li&gt;
  &lt;li&gt;releaseAll: すべてのキーを離す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;キーの指定は、英数記号の場合、文字をそのまま渡す。
大文字を渡すと自動でシフトキーが補完され大文字での入力になる。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bleKeyboard.write('a');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ファンクションキー、修飾キーなどの場合は
&lt;a href=&quot;https://github.com/T-vK/ESP32-BLE-Keyboard/blob/master/BleKeyboard.h&quot;&gt;BleKeyboard.h&lt;/a&gt;
で定義されている定数を渡す。&lt;/p&gt;

&lt;h2 id=&quot;スケッチの作成&quot;&gt;スケッチの作成&lt;/h2&gt;

&lt;p&gt;M5StickC のボタンA (正面の「M5」ボタン) を押すと
500ms 間隔で順番に B, L, E, Enterキーを押すサンプルスケッチを作成した。
今回は同時押しが不要だったため
keystroke に書かれたキーを順に write で出力するだけとなっている。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;lt;BleKeyboard.h&amp;gt;

// -----------------------------------------------------------------------------
// 定数
// -----------------------------------------------------------------------------
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;
// キーと待ち時間の構造体
struct Key {
  uint8_t key;
  uint32_t delay;
};
// 送信するキーストローク
const std::vector&amp;lt;Key&amp;gt; keystroke = {
    { &amp;#39;B&amp;#39;       , 500 },
    { &amp;#39;L&amp;#39;       , 500 },
    { &amp;#39;E&amp;#39;       , 500 },
    { KEY_RETURN, 0 }
};

// -----------------------------------------------------------------------------
// 変数
// -----------------------------------------------------------------------------
// ESP32-BLE-Keyboard
BleKeyboard bleKeyboard;

// -----------------------------------------------------------------------------
// 関数
// -----------------------------------------------------------------------------
// 画面を消去する
void clearScreen() {
    M5.Lcd.fillScreen(TFT_BLACK);
    M5.Lcd.setCursor(0, 0);
}

// キーストロークを送信する
void sendKeystroke() {
    clearScreen();
    M5.Lcd.println(&amp;quot;Sending...&amp;quot;);

    for (const auto&amp;amp; n : keystroke) {
        bleKeyboard.write(n.key);
        delay(n.delay);
    }

    M5.Lcd.println(&amp;quot;Complete!&amp;quot;);
}

void setup() {
    M5.begin();

    // 画面の表示設定
    M5.Lcd.setRotation(1);
    M5.Lcd.setTextFont(2);
    clearScreen();
    M5.Lcd.println(&amp;quot;ESP32-BLE-Keyboard&amp;quot;);

    // Bluetooth接続
    bleKeyboard.begin();
}

void loop() {
    M5.update();

    // 電源ボタンが押されたらリセット
    if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
        esp_restart();
    }

    if (bleKeyboard.isConnected()) {
        // Bluetooth接続済みの場合
        // ボタンAが押されたらキーを送信
        if (M5.BtnA.wasPressed()) {
            sendKeystroke();
        }

        delay(10);
    }
    else {
        // Bluetooth未接続の場合は5秒待つ
        M5.Lcd.println(&amp;quot;Waiting 5 seconds...&amp;quot;);
        delay(5000);
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/95c34469ebd1186c12398fbeb8266d17.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;動作確認&quot;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;以下の手順で動作を確認できる。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;M5StickC にスケッチを書き込む&lt;/li&gt;
  &lt;li&gt;M5StickC の画面に “Waiting 5 seconds…” と表示されていることを確認&lt;/li&gt;
  &lt;li&gt;PC で Bluetooth デバイスを検索し “ESP32 BLE Keyboard” へ接続&lt;/li&gt;
  &lt;li&gt;メモ帳などのアプリを開く&lt;/li&gt;
  &lt;li&gt;M5StickC のボタンA (正面の「M5」ボタン) を押す&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これで複雑なキーボードマクロでも思い通りに実行できるようになった。
キーボードでできることなら何でもボタン一発で実行できるため、
思っていた以上に利便性が高い。&lt;/p&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://neocat.hatenablog.com/entry/2019/09/28/151947&quot;&gt;ESP32をBluetoothキーボードやマウスにする - Okiraku Programming&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/T-vK/ESP32-BLE-Keyboard&quot;&gt;T-vK/ESP32-BLE-Keyboard: Bluetooth LE Keyboard library for the ESP32 (Arduino IDE compatible)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Apr 2021 05:50:17 +0900</pubDate>
        <link>https://saasan.github.io/blog/2021/04/04/m5stickc%E3%81%A7%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89%E6%93%8D%E4%BD%9C%E3%82%92%E8%87%AA%E5%8B%95%E5%8C%96%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2021/04/04/m5stickc%E3%81%A7%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89%E6%93%8D%E4%BD%9C%E3%82%92%E8%87%AA%E5%8B%95%E5%8C%96%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC</category>
        
        <category>M5Stack</category>
        
        <category>ESP32</category>
        
        <category>ESP32-BLE-Keyboard</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC で毎朝照明を自動で点灯する</title>
        <description>&lt;p&gt;最近寒いのでカーテンを遮光・遮熱のものに変えた。
遮熱のほうはあまり実感がないが遮光のほうはばっちりで、
昼間でもカーテンを閉めれば部屋がかなり暗くなる。&lt;/p&gt;

&lt;p&gt;寝てる間は暗くてよいのだが、
朝になっても明るさで自然に目が覚めるということがなくなった。
時計を見ないと大まかな時間すら分からないのは思いの外不便だ。
そこで、以前購入した M5StickC を使って
毎朝自動で照明を点灯させることを思いついた。&lt;/p&gt;

&lt;h2 id=&quot;使用する照明器具とリモコン&quot;&gt;使用する照明器具とリモコン&lt;/h2&gt;

&lt;p&gt;私の部屋の照明はNECライティング(現ホタルクス)の
&lt;a href=&quot;https://www.amazon.co.jp/gp/product/B07SS94YPN/saasan-22&quot;&gt;LEDシーリングライトHLDX0801&lt;/a&gt;
を使用している。
昨年買い換えたのだが、
これはシーリングライトとしてはかなりの薄型で、
引掛シーリングと合わせても高さ6cmくらいしかない。
以前使用していたものは高さ15cmほどあったため、
圧迫感がなくなり気に入っている。
唯一の不満点はリモコンが付属していないことで、別途
&lt;a href=&quot;https://www.amazon.co.jp/dp/B075FBKZBT/saasan-22&quot;&gt;RE0206&lt;/a&gt;
を購入し使用している。&lt;/p&gt;

&lt;h2 id=&quot;リモコンの信号解析&quot;&gt;リモコンの信号解析&lt;/h2&gt;

&lt;p&gt;まずは点灯時に RE0206 から発信される赤外線信号を調べるため
&lt;a href=&quot;https://www.amazon.co.jp/dp/B07Z621FQC/saasan-22&quot;&gt;Grove 接続の IR ユニット&lt;/a&gt;
を購入した。
M5StickC 単体でも赤外線の発信はできるが、受信はできないため、
リモコンの信号を調べる場合は別途購入する必要がある。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://siroitori.hatenablog.com/entry/2020/04/25/114250&quot;&gt;M5StickC／M5Stack Fireで赤外線リモコンを作ろうと四苦八苦したのでメモ - カワリモノ息子の技術メモ的な〜&lt;/a&gt;
を参考に Arduino IDE から
IRremoteESP8266 をインストールし、スケッチ例の IRvecvDumpV3 を開く。
kRecvPin を 33 に変更して M5StickC へ書き込んだあと、
IR ユニットへ向けてリモコンのボタンを押すと
シリアルモニタへ信号が表示された。&lt;/p&gt;

&lt;p&gt;赤外線リモコンの信号にはいくつか種類があるらしいが、
NEC製品なので当然NECフォーマットだった。&lt;/p&gt;

&lt;h2 id=&quot;スケッチの作成&quot;&gt;スケッチの作成&lt;/h2&gt;

&lt;p&gt;M5StickC で設定時刻に赤外線信号を送信するスケッチを作成した。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/saasan/m5stickc-ir-timer&quot;&gt;saasan/m5stickc-ir-timer: M5StickCで設定時刻に赤外線信号を送信する&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://gist-it.appspot.com/github/saasan/m5stickc-ir-timer/raw/master/m5stickc-ir-timer.ino&quot;&gt;&lt;/script&gt;

&lt;p&gt;IR_SEND_DATA の 0x41B6659A が上記で解析した点灯するための信号で、
これを IRsend クラスの sendNEC メソッドで送信している。&lt;/p&gt;

&lt;p&gt;タイマーの時刻は
ボタンA(正面の「M5」ボタン)で時、
ボタンB(側面の小さいボタン)で分を変更できるようにした。&lt;/p&gt;

&lt;p&gt;送信するリモコンの信号を変えればいろいろと応用できそう。&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Jan 2021 10:05:33 +0900</pubDate>
        <link>https://saasan.github.io/blog/2021/01/03/m5stickc%E3%81%A7%E6%AF%8E%E6%9C%9D%E7%85%A7%E6%98%8E%E3%82%92%E8%87%AA%E5%8B%95%E3%81%A7%E7%82%B9%E7%81%AF%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2021/01/03/m5stickc%E3%81%A7%E6%AF%8E%E6%9C%9D%E7%85%A7%E6%98%8E%E3%82%92%E8%87%AA%E5%8B%95%E3%81%A7%E7%82%B9%E7%81%AF%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC</category>
        
        <category>M5Stack</category>
        
        <category>ESP32</category>
        
        <category>IRremoteESP8266</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>消してしまった WSL 環境のバックアップからファイルを取り出す</title>
        <description>&lt;p&gt;PC を新しいものへ移行する際に WSL 環境の中身を移行するのを忘れていた。
というか、別の環境に最新のファイルがあると思い込んでいたので敢えて移行しなかったのだ。
実際は自分の旧 PC の WSL 環境にあったものが最新のファイルで、
それに気付いたときにはディスクの初期化が済んでいた。&lt;/p&gt;

&lt;p&gt;旧 PC の Ubuntu 内には作業中のファイルがあり、
これが消えてしまうと10時間ほどかけた作業が無駄になってしまう。
こんなこともあろうかと、旧 PC のディスクを
&lt;a href=&quot;https://docs.microsoft.com/en-us/sysinternals/downloads/disk2vhd&quot;&gt;Disk2vhd&lt;/a&gt;
で VHDX ファイル化したものは残しておいたので、
このバックアップファイルから必要なファイルを取り出すことにした。&lt;/p&gt;

&lt;h2 id=&quot;旧-pc-のバックアップから-ubuntu-のディスクイメージを探す&quot;&gt;旧 PC のバックアップから Ubuntu のディスクイメージを探す&lt;/h2&gt;

&lt;p&gt;まずは旧 PC のバックアップから Ubuntu のディスクイメージを探す。
VHDX ファイルをダブルクリックすると自動でマウントされるので
その中を探したところ以下のパスにディスクイメージがあった。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;\Users\ユーザー名\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\ext4.vhdx&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;このファイルをマウントして中身を取り出して完了かと思ったら、
ファル名通りファイルシステムが ext4 だからなのか
Windows ではマウントできなかった。&lt;/p&gt;

&lt;p&gt;しかたないので新 PC の WSL へ新しいディストリビューションを入れて
ext4.vhdx を置き換えることにする。&lt;/p&gt;

&lt;h2 id=&quot;alpine-wsl-をインストールする&quot;&gt;Alpine WSL をインストールする&lt;/h2&gt;

&lt;p&gt;ext4.vhdx からファイルを取り出すため
&lt;a href=&quot;https://www.microsoft.com/ja-jp/p/alpine-wsl/9p804crf0395?activetab=pivot:overviewtab&quot;&gt;Alpine WSL&lt;/a&gt;
をインストールした。
これはおそらく新 PC で使ってないディストリビューションならなんでもいい。
新 PC でも既に Ubuntu を使い始めていたのでそれ以外で、
インストール作業に時間をかけたくないこともあり
軽量なことで有名な Alpine Linux を選択した。&lt;/p&gt;

&lt;p&gt;インストール後、念のため一度起動して初期設定を行っておく。&lt;/p&gt;

&lt;h2 id=&quot;wsl-のサービスを停止して-ext4vhdx-を置き換える&quot;&gt;WSL のサービスを停止して ext4.vhdx を置き換える&lt;/h2&gt;

&lt;p&gt;WSL のサービスが起動したままだとファイルがロックされていて置き換えられない。
コマンドプロンプトか PowerShell を管理者権限で起動し、
以下のコマンドで WSL のサービスを止める。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net stop LxssManager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次に以下のパスにある Alpine WSL の ext4.vhdx
を旧 PC のバックアップから取り出したもので置き換える。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;\Users\ユーザー名\AppData\Local\Packages\36828agowa338.AlpineWSL_my43bytk1c4nr\LocalState\ext4.vhdx&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最後に以下のコマンドで WSL のサービスを起動する。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net start LxssManager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;必要なファイルを取り出す&quot;&gt;必要なファイルを取り出す&lt;/h2&gt;

&lt;p&gt;あとは alpine コマンドで起動し旧 PC の
Ubuntu 環境へ入ってファイルを取り出すことができた。&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Dec 2020 22:44:17 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/12/25/%E6%B6%88%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9Fwsl%E7%92%B0%E5%A2%83%E3%81%AE%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%81%8B%E3%82%89%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/12/25/%E6%B6%88%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%A3%E3%81%9Fwsl%E7%92%B0%E5%A2%83%E3%81%AE%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%81%8B%E3%82%89%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99.html</guid>
        
        <category>Windows</category>
        
        <category>WSL</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>最近知った Bash の便利機能</title>
        <description>&lt;h2 id=&quot;cd--&quot;&gt;cd -&lt;/h2&gt;

&lt;p&gt;一つ前のディレクトリへ戻る。&lt;/p&gt;

&lt;p&gt;pushd / popd で2つのディレクトリを往復することがあったけどこっちのほうが速い。&lt;/p&gt;

&lt;h1 id=&quot;ctrl--u-ctrl--y&quot;&gt;Ctrl + u, Ctrl + y&lt;/h1&gt;

&lt;p&gt;&lt;kbd&gt;Ctrl + u&lt;/kbd&gt; でカーソル位置から行頭まで切り取る。
&lt;kbd&gt;Ctrl + y&lt;/kbd&gt; で切り取ったものを貼り付ける。&lt;/p&gt;

&lt;p&gt;&lt;kbd&gt;git commit -m &quot;hoge&quot;&lt;/kbd&gt; とか書いたところで &lt;kbd&gt;git add&lt;/kbd&gt; してないことに気付いたりとか、
コマンド入力中に別のコマンドを先に実行したくなったときに便利。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;kbd&gt;Ctrl + k&lt;/kbd&gt; ならカーソル位置から行末まで切り取れる。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Dec 2020 23:25:18 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/12/16/%E6%9C%80%E8%BF%91%E7%9F%A5%E3%81%A3%E3%81%9Fbash%E3%81%AE%E4%BE%BF%E5%88%A9%E6%A9%9F%E8%83%BD.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/12/16/%E6%9C%80%E8%BF%91%E7%9F%A5%E3%81%A3%E3%81%9Fbash%E3%81%AE%E4%BE%BF%E5%88%A9%E6%A9%9F%E8%83%BD.html</guid>
        
        <category>Linux</category>
        
        <category>Bash</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>スタートメニューから消えた Dell Command | Update を復活させる</title>
        <description>&lt;p&gt;Dell Command | Update を実行したあとにスタートメニューから Dell Command | Update が消えることがある。&lt;/p&gt;

&lt;p&gt;しばらく待っていれば自動で復活することもあれば復活しないこともある。
復活しないときは一度アンインストールして
&lt;a href=&quot;https://www.dell.com/support/article/ja-jp/sln311129/dell-command-update?lang=ja&quot;&gt;Dell のサイトからダウンロード&lt;/a&gt;
したものを入れ直していたが、けっこう手間がかかって面倒だった。
そもそもアプリの一覧に残ってるならもっと簡単に復活できるんじゃないか？&lt;/p&gt;

&lt;p&gt;そう思ってスタートメニューだけ復活させる方法がないか調べたら以下の方法で復活できた。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;管理者権限で PowerShell を起動する。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下のコマンドを実行する。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ManifestPath = (Get-AppxPackage -AllUsers -Name &quot;DellInc.DellCommandUpdate&quot;).InstallLocation + &quot;\Appxmanifest.xml&quot;
Add-AppxPackage -Path $ManifestPath -Register -DisableDevelopmentMode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;※Get-AppxPackage に -AllUsers オプションを付けて実行するのに管理者権限が必要。&lt;/p&gt;

&lt;p&gt;参考 : &lt;a href=&quot;https://docs.microsoft.com/ja-jp/powershell/module/appx/add-appxpackage?view=winserver2012r2-ps#example-2&quot;&gt;Add-AppxPackage (AppX) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Nov 2020 00:46:11 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/11/14/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%83%A1%E3%83%8B%E3%83%A5%E3%83%BC%E3%81%8B%E3%82%89%E6%B6%88%E3%81%88%E3%81%9F-dell-command-update-%E3%82%92%E5%BE%A9%E6%B4%BB%E3%81%95%E3%81%9B%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/11/14/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%83%A1%E3%83%8B%E3%83%A5%E3%83%BC%E3%81%8B%E3%82%89%E6%B6%88%E3%81%88%E3%81%9F-dell-command-update-%E3%82%92%E5%BE%A9%E6%B4%BB%E3%81%95%E3%81%9B%E3%82%8B.html</guid>
        
        <category>PC</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>USB CABLE CHECKER 2 で USB Type-C ケーブルの性能を確認する</title>
        <description>&lt;p&gt;先日 RAVPower 製 90W USB PD 充電器 RP-PC128 を買いました。
同じく RAVPower 製の 61W USB PD 充電器 PR-PC112 を持っていたのですが、
65W を要求する Dell 製ノート PC に給電しながら電源を入れると
途中で電力が足りない旨メッセージが表示されて起動が一時停止したり、
Windows 10 起動後も電力不足の通知が表示されるという状態で煩わしかったためです。&lt;/p&gt;

&lt;p&gt;eMarker 付きのケーブルを持っていなかったので
RAMPOW という謎のメーカーの PD 3.0 / USB 3.1 Gen2 対応を謳う USB Type-C ケーブルと
Bit Trade One の
&lt;a href=&quot;https://bit-trade-one.co.jp/adusbcim/&quot;&gt;USB CABLE CHECKER 2 (ADUSBCIM)&lt;/a&gt;
もついでに購入しました。&lt;/p&gt;

&lt;p&gt;RAMPOW は &lt;a href=&quot;https://rampow.com/&quot;&gt;Web サイト&lt;/a&gt; を見ても本社所在地や電話番号等が一切書かれておらず怪しげなメーカーという印象だったため、
ケーブルを使用する前に念の為 USB CABLE CHECKER 2 で確認しようという寸法です。
(※購入後に気付いたのですが、RAMPOW の
&lt;a href=&quot;https://www.amazon.co.jp/sp?_encoding=UTF8&amp;amp;seller=A2RPIWYAIJTBUL&quot;&gt;Amazon出品者プロフィール&lt;/a&gt;
に住所と電話番号が書かれていました。中国深センの会社のようです。)&lt;/p&gt;

&lt;iframe style=&quot;width:120px;height:240px;&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; src=&quot;https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;amp;t=saasan-22&amp;amp;m=amazon&amp;amp;o=9&amp;amp;p=8&amp;amp;l=as1&amp;amp;IS2=1&amp;amp;detail=1&amp;amp;asins=B0872MGDR2&amp;amp;linkId=fac28b4b22c51e4280bc86287fd8dd0a&amp;amp;bc1=000000&amp;amp;lt1=_blank&amp;amp;fc1=333333&amp;amp;lc1=0066c0&amp;amp;bg1=ffffff&amp;amp;f=ifr&quot;&gt;&lt;/iframe&gt;

&lt;iframe style=&quot;width:120px;height:240px;&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; src=&quot;https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;amp;t=saasan-22&amp;amp;m=amazon&amp;amp;o=9&amp;amp;p=8&amp;amp;l=as1&amp;amp;IS2=1&amp;amp;detail=1&amp;amp;asins=B0827NDHBQ&amp;amp;linkId=bc50d175b4811fb8739a0a5d77f6be35&amp;amp;bc1=000000&amp;amp;lt1=_blank&amp;amp;fc1=333333&amp;amp;lc1=0066c0&amp;amp;bg1=ffffff&amp;amp;f=ifr&quot;&gt;&lt;/iframe&gt;

&lt;iframe style=&quot;width:120px;height:240px;&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; src=&quot;https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;amp;t=saasan-22&amp;amp;m=amazon&amp;amp;o=9&amp;amp;p=8&amp;amp;l=as1&amp;amp;IS2=1&amp;amp;detail=1&amp;amp;asins=B07Y8BPVV4&amp;amp;linkId=b4348a77ed22af3503ea6572a01d34e9&amp;amp;bc1=000000&amp;amp;lt1=_blank&amp;amp;fc1=333333&amp;amp;lc1=0066c0&amp;amp;bg1=ffffff&amp;amp;f=ifr&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;rampow-製ケーブル-rad03&quot;&gt;RAMPOW 製ケーブル RAD03&lt;/h2&gt;

&lt;p&gt;さっそく RAMPOW 製ケーブルを確認してみます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/blog/2020-07-19/rampow.jpg&quot;&gt;&lt;img src=&quot;/img/blog/2020-07-19/rampow.jpg&quot; alt=&quot;RAMPOW 製ケーブル RAD03&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;USB CABLE CHECKER 2 の表示は以下の通り。&lt;/p&gt;

&lt;pre&gt;GND+VBUS=188mΩ
CC:DOWN1K/E-MARKED
SHELL-GND SHORT(A&amp;amp;B)&lt;/pre&gt;

&lt;p&gt;表示の意味については
&lt;a href=&quot;https://github.com/bit-trade-one/USBCableChecker2/blob/master/README.md&quot;&gt;取扱説明書&lt;/a&gt;
に記載されています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[DOWN1K/E-MARKED]&lt;/p&gt;

  &lt;p&gt;Cプラグ内にGND-VCONN間に接続された1kΩの抵抗器を持ちます。&lt;/p&gt;

  &lt;p&gt;これにより接続先USB機器にEマーカーIC内蔵ケーブルということを通知します。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[SHELL-GND SHORT(SIDE)]&lt;/p&gt;

  &lt;p&gt;プラグシェルがGNDと導通している場合表示されます。()内は導通している側のコネクタがA,Bどちらかを表します。&lt;/p&gt;

  &lt;p&gt;両側のコネクタが導通している場合はA&amp;amp;Bと表示されます。&lt;/p&gt;

  &lt;p&gt;なお、タイプC-Cケーブルでは規格でGNDとシェルが接続されることが定められています。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;samp&gt;CC:DOWN1K/E-MARKED&lt;/samp&gt; は eMarker 内蔵、
&lt;samp&gt;SHELL-GND SHORT(A&amp;amp;B)&lt;/samp&gt; は両側のプラグシェルが GND と導通していることを示しています。&lt;/p&gt;

&lt;p&gt;eMarker が内蔵されているため 3A を超える電流が流せます。
connection のランプも全点灯しており、PD 3.0 / USB 3.1 Gen2 対応を謳うケーブルとして特に問題なさそうです。&lt;/p&gt;

&lt;h2 id=&quot;ravpower-製充電器-rp-pc128-付属ケーブル&quot;&gt;RAVPower 製充電器 RP-PC128 付属ケーブル&lt;/h2&gt;

&lt;p&gt;購入時に気付いてなかったのですが、
RP-PC128 にも 1.5m の Type-C ケーブルが付属していたためこれも確認してみます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/blog/2020-07-19/ravpower.jpg&quot;&gt;&lt;img src=&quot;/img/blog/2020-07-19/ravpower.jpg&quot; alt=&quot;RAVPower 製 90W USB PD 充電器 RP-PC128 付属ケーブル&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;GND+VBUS=170mΩ
CC:DOWN1K/E-MARKED
SHELL-GND SHORT(A&amp;amp;B)&lt;/pre&gt;

&lt;p&gt;eMarker が内蔵されているため 3A を超える電流が流せます。
connection のランプは USB 2.0 の部分と CC (Configuration Channel) が点灯しています。
USB 2.0 対応の PD ケーブルとして使えるようです。&lt;/p&gt;

&lt;p&gt;電源ケーブルとして使うならこれで十分ですね。
&lt;del&gt;RAMPOW のケーブルいらなかったのでは？&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;lenovo-yoga-book-c930-付属ケーブル&quot;&gt;Lenovo Yoga Book C930 付属ケーブル&lt;/h2&gt;

&lt;p&gt;手元にあったほかの USB Type-C ケーブルも確認してみます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/blog/2020-07-19/lenovo.jpg&quot;&gt;&lt;img src=&quot;/img/blog/2020-07-19/lenovo.jpg&quot; alt=&quot;Lenovo Yoga Book C930 付属ケーブル&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;GND+VBUS=212mΩ
SHELL-GND SHORT(A&amp;amp;B)&lt;/pre&gt;

&lt;p&gt;eMarker が内蔵されていないため 3A までの電流しか流せません。
connection のランプは USB 3.2 が一部点灯しています。&lt;/p&gt;

&lt;p&gt;USB 3.0, 3.1 では TX1/RX1 と TX2/RX2 のどちらかが繋がっていれば良いようです。
USB 3.2 Gen 2x2 では TX1, TX2, RX1, RX2 のすべてを使用してより高速な通信を行うため、このケーブルは利用できません。&lt;/p&gt;

&lt;p&gt;SBU (Sideband Use) は USB では使用されず、
DisplayPort 出力や Thunderbolt などの Alternate Mode に使われる信号線のようです。&lt;/p&gt;

&lt;p&gt;USB 3.1 対応の PD ケーブルとしては使えそう。&lt;/p&gt;

&lt;h2 id=&quot;one-netbook-onemix3s-付属ケーブル&quot;&gt;One-Netbook OneMix3S 付属ケーブル&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/img/blog/2020-07-19/onemix3s.jpg&quot;&gt;&lt;img src=&quot;/img/blog/2020-07-19/onemix3s.jpg&quot; alt=&quot;One-Netbook OneMix3S 付属ケーブル&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;GND+VBUS=225mΩ&lt;/pre&gt;

&lt;p&gt;&lt;samp&gt;SHELL-GND SHORT(A&amp;amp;B)&lt;/samp&gt; の表示がない……。
規格に従ってないケーブルのようです。
これは使わないほうがよさそう。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;RAVPower 製 90W USB PD 充電器 RP-PC128 と RAMPOW 製ケーブル RAD03 の組み合わせで、
65W を要求する Dell 製ノート PC が問題なく充電できました。&lt;/p&gt;

&lt;p&gt;RP-PC128 は MacBook 付属の 61W USB-C 充電器と比べて
サイズがひと回り小さい (65 x 65 x 32 mm) ため持ち運びやすく、
90W の大出力により充電できる機器の幅が広がります。&lt;/p&gt;

&lt;p&gt;また、電力に余裕があるため、BUFFALO の
5-in-1 ドッキングステーション LUD-U3-CGD/N
を間にはさんでも安定して動作しています
(61W 出力の PR-PC112 を使用したときは有線 LAN の通信がブツブツ切れていた)。
ケーブル1本で電源、ディスプレイ、有線 LAN、キーボードが繋がるのは便利です。&lt;/p&gt;

&lt;iframe style=&quot;width:120px;height:240px;&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; src=&quot;https://rcm-fe.amazon-adsystem.com/e/cm?ref=tf_til&amp;amp;t=saasan-22&amp;amp;m=amazon&amp;amp;o=9&amp;amp;p=8&amp;amp;l=as1&amp;amp;IS2=1&amp;amp;detail=1&amp;amp;asins=B081ZZGWR7&amp;amp;linkId=9a6e62087527f859adc8ac8b19af537f&amp;amp;bc1=000000&amp;amp;lt1=_blank&amp;amp;fc1=333333&amp;amp;lc1=0066c0&amp;amp;bg1=ffffff&amp;amp;f=ifr&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;今回購入した RAMPOW 製ケーブルは問題ありませんでしたが、
手持ちの OneMix3S 付属ケーブルが規格違反だったのは意外でした。
USB Power Delivery では高電圧、大電流が流れるため、
ケーブル購入の際は信頼できるメーカーのものを選んだほうがよさそうです。&lt;/p&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bit-trade-one/USBCableChecker2/blob/master/README.md&quot;&gt;USBCableChecker2/README.md at master · bit-trade-one/USBCableChecker2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ascii.jp/elem/000/001/848/1848727/&quot;&gt;ASCII.jp：USB 4の発表で、USB 3.2はどうなった？ (1/5)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.4gamer.net/games/999/G999902/20190403022/&quot;&gt;USB 3.2とUSB4は従来のUSB規格から何が変わるのか？ 混乱しがちなUSBの最新事情を説明しよう - 4Gamer.net&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://lab.fujiele.co.jp/articles/8968/&quot;&gt;USB Type-Cに置き換える方法 第1話 Type-Cの原理を知る | 組込み技術ラボ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Jul 2020 09:00:00 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/07/19/usb-cable-checker-2%E3%81%A7usb-type-c%E3%82%B1%E3%83%BC%E3%83%96%E3%83%AB%E3%81%AE%E6%80%A7%E8%83%BD%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/07/19/usb-cable-checker-2%E3%81%A7usb-type-c%E3%82%B1%E3%83%BC%E3%83%96%E3%83%AB%E3%81%AE%E6%80%A7%E8%83%BD%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC + Speaker Hat で ESP8266Audio ライブラリを使用して MP3 ファイルを再生する</title>
        <description>&lt;p&gt;前回の
&lt;a href=&quot;/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html&quot;&gt;M5StickC + Speaker Hat で SPIFFS から読み込んだ WAV ファイルを再生する&lt;/a&gt;
では自力で WAV ファイルを読み込んでいましたが、
&lt;a href=&quot;https://github.com/earlephilhower/ESP8266Audio&quot;&gt;ESP8266Audio&lt;/a&gt;
というライブラリを用いることで ESP32-PICO 搭載の M5StickC でも MP3 が再生できることを教えて頂きました。
ということで、今回は事前に SPIFFS へ保存した MP3 ファイルを ESP8266Audio で読み込んで再生します。&lt;/p&gt;

&lt;h2 id=&quot;スケッチ&quot;&gt;スケッチ&lt;/h2&gt;

&lt;p&gt;以下は A ボタン(正面の「M5」ボタン)を押すと MP3 ファイルが再生されるスケッチです。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;quot;FS.h&amp;quot;
#include &amp;quot;SPIFFS.h&amp;quot;
#include &amp;quot;AudioFileSourceSPIFFS.h&amp;quot;
#include &amp;quot;AudioGeneratorMP3.h&amp;quot;
#include &amp;quot;AudioOutputI2S.h&amp;quot;

// オーディオファイル名
const char AUDIO_FILE_NAME[] = &amp;quot;/hoge.mp3&amp;quot;;

const int I2S_NUM_0 = 0;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

AudioGeneratorMP3 *generator = NULL;
AudioFileSourceSPIFFS *source = NULL;
AudioOutputI2S *output = NULL;

// メッセージ出力
void showMessage(const char *message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 35);
    M5.Lcd.setTextFont(2);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

void playAudio() {
    Serial.println(&amp;quot;playAudio&amp;quot;);

    stopAudio();
    if (!source-&amp;gt;isOpen()) {
        source-&amp;gt;open(AUDIO_FILE_NAME);
    }
    generator-&amp;gt;begin(source, output);
}

void stopAudio() {
    Serial.println(&amp;quot;stopAudio&amp;quot;);

    if (generator-&amp;gt;isRunning()) {
        generator-&amp;gt;stop();
    }
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;ESP8266Audio&amp;quot;);

    // シリアルモニターの設定
    Serial.begin(115200);
    audioLogger = &amp;amp;Serial;

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&amp;quot;SPIFFS Mount Failed&amp;quot;);
        return;
    }

    source = new AudioFileSourceSPIFFS(AUDIO_FILE_NAME);
    output = new AudioOutputI2S(I2S_NUM_0, AudioOutputI2S::INTERNAL_DAC);
    generator = new AudioGeneratorMP3();
}

void loop() {
    delay(10);

    if (generator-&amp;gt;isRunning()) {
        if (!generator-&amp;gt;loop()) {
            stopAudio();
        }
    }
    else {
        // ボタンの状態を更新
        M5.update();

        // Aボタンが押されたら音声データ再生
        if (M5.BtnA.wasPressed()) {
            playAudio();
        }

        // 電源ボタンが押されたらリセット
        if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
            esp_restart();
        }
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/ed2ee155ed1a16865015c1967cf875c3.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;SPIFFS からファイルを読み込む AudioFileSourceSPIFFS クラス、
MP3 を再生する AudioGeneratorMP3 クラス、
I2S で出力する AudioOutputI2S クラスを使用しています。
ESP8266Audio は MP3 以外にも WAV, FLAC, MIDI, AAC などのファイル形式を読み込めるようになっており、
それぞれのファイル形式に対応した generator クラスを使用する必要があります。&lt;/p&gt;

&lt;p&gt;generator-&amp;gt;isRunning() で再生中か確認し、再生中でない場合にボタンが押されたら MP3 ファイルを再生しています。
一度再生が終わり generator-&amp;gt;stop() を呼び出すとファイルが閉じられます。
そのため、2回目以降の再生時はファイルを再び開く必要があります。
source-&amp;gt;isOpen() でファイルが開かれているかを確認し、
開かれていない場合は source-&amp;gt;open() でファイルを開いています。&lt;/p&gt;

&lt;p&gt;AudioFileSourceSPIFFS クラスでは再生する度にファイルを読み込むため、
ESP32-PICO のメモリ (520KB) に収まるサイズのファイルを何度も再生するのであれば、
以下のように setup() 内でファイルを読み込み
AudioFileSourcePROGMEM クラスを使用した方がよいかと思います。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;quot;FS.h&amp;quot;
#include &amp;quot;SPIFFS.h&amp;quot;
#include &amp;quot;AudioFileSourcePROGMEM.h&amp;quot;
#include &amp;quot;AudioGeneratorMP3.h&amp;quot;
#include &amp;quot;AudioOutputI2S.h&amp;quot;

// オーディオファイル名
const char AUDIO_FILE_NAME[] = &amp;quot;/hoge.mp3&amp;quot;;

const int I2S_NUM_0 = 0;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

AudioGeneratorMP3 *generator = NULL;
AudioFileSourcePROGMEM *source = NULL;
AudioOutputI2S *output = NULL;
uint8_t *audioData = NULL;
size_t audioDataSize = 0;

// メッセージ出力
void showMessage(const char *message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 35);
    M5.Lcd.setTextFont(2);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

void readAudioFile(fs::FS&amp;amp; fs, const char* path) {
    File file = fs.open(path);
    if (!file || file.isDirectory()) {
        Serial.println(&amp;quot;- failed to open file for reading&amp;quot;);
        return;
    }

    audioDataSize = file.size();
    audioData = new uint8_t[audioDataSize];
    file.read(audioData, audioDataSize);
}

void playAudio() {
    Serial.println(&amp;quot;playAudio&amp;quot;);

    stopAudio();
    if (!source-&amp;gt;isOpen()) {
        source-&amp;gt;open(audioData, audioDataSize);
    }
    generator-&amp;gt;begin(source, output);
}

void stopAudio() {
    Serial.println(&amp;quot;stopAudio&amp;quot;);

    if (generator-&amp;gt;isRunning()) {
        generator-&amp;gt;stop();
    }
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;ESP8266Audio&amp;quot;);

    // シリアルモニターの設定
    Serial.begin(115200);
    audioLogger = &amp;amp;Serial;

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&amp;quot;SPIFFS Mount Failed&amp;quot;);
        return;
    }

    readAudioFile(SPIFFS, AUDIO_FILE_NAME);

    source = new AudioFileSourcePROGMEM(audioData, audioDataSize);
    output = new AudioOutputI2S(I2S_NUM_0, AudioOutputI2S::INTERNAL_DAC);
    generator = new AudioGeneratorMP3();
}

void loop() {
    delay(10);

    if (generator-&amp;gt;isRunning()) {
        if (!generator-&amp;gt;loop()) {
            stopAudio();
        }
    }
    else {
        // ボタンの状態を更新
        M5.update();

        // Aボタンが押されたら音声データ再生
        if (M5.BtnA.wasPressed()) {
            playAudio();
        }

        // 電源ボタンが押されたらリセット
        if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
            esp_restart();
        }
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/b6d9cb8fc8786d9c0407560f6206af22.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;自力での-wav-ファイル再生との比較&quot;&gt;自力での WAV ファイル再生との比較&lt;/h2&gt;

&lt;p&gt;前回行った自力での WAV ファイル再生では 8bit, 8000Hz 限定だったこともあり、
比較すると音質はかなり改善しましたが、
再生の前後にプチプチとノイズが入るようになりました。
また、コンパイルにかかる時間もかなり長くなっています。&lt;/p&gt;

&lt;p&gt;コンパイル時間はどうしようもないと思いますが、
再生前後のプチプチは下記参考サイトのクリックノイズ対策を行えば消せるかもしれません。&lt;/p&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/earlephilhower/ESP8266Audio&quot;&gt;earlephilhower/ESP8266Audio: Arduino library to play MOD, WAV, FLAC, MIDI, RTTTL, MP3, and AAC files on I2S DACs or with a software emulated delta-sigma DAC on the ESP8266 and ESP32&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/odetarou/items/0f37ed2eeeb9bd051c0c&quot;&gt;ESP32でGoogle Play Musicを再生する - Qiita&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog-yama.a-quest.com/?eid=970190&quot;&gt;ESP32でサウンド出力時のクリックノイズ対策（I2S+内蔵DAC） | N.Yamazaki’s blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 17 Jun 2020 19:59:34 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/06/17/m5stickc-speaker-hat%E3%81%A7esp8266audio%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6mp3%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/06/17/m5stickc-speaker-hat%E3%81%A7esp8266audio%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6mp3%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC</category>
        
        <category>M5Stack</category>
        
        <category>ESP32</category>
        
        <category>ESP8266Audio</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC + Speaker Hat で SPIFFS から読み込んだ WAV ファイルを再生する</title>
        <description>&lt;p&gt;前回の
&lt;a href=&quot;/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html&quot;&gt;M5StickC + Speaker Hat で音声データを再生する&lt;/a&gt;
では音声データを直接スケッチ上に書くというスマートとは言い難い方法でした。
今回は事前に SPIFFS へ保存した WAV ファイルを読み込んで再生します。&lt;/p&gt;

&lt;h2 id=&quot;wav-ファイルの作成&quot;&gt;WAV ファイルの作成&lt;/h2&gt;

&lt;p&gt;まずは再生したい音声データを以下の形式の WAV ファイルへ変換します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;モノラル&lt;/li&gt;
  &lt;li&gt;サンプリング周波数8000Hz&lt;/li&gt;
  &lt;li&gt;Unsigned 8-bit PCM&lt;/li&gt;
  &lt;li&gt;メタデータなし&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スピーカーが1つなのでモノラル、
M5StickC (というか ESP32) の DAC が 8 ビットなので WAV ファイルも 8 ビットです。
サンプリング周波数は 8000Hz じゃなくてもいいかもしれませんが、
一般的に使用されている 44100Hz ではうまく動作しなかったためこの値にしています。&lt;/p&gt;

&lt;p&gt;また、今回のスケッチではメタデータを一切考慮していないため、
メタデータがあるとシリアルモニタへ “invalid wave file header”
というエラーメッセージが表示されファイルが読み込まれません。&lt;/p&gt;

&lt;p&gt;以下は
&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;FFmpeg&lt;/a&gt;
で変換する場合のコマンド例です。
FFmpeg で変換すると「Lavf58.29.100」(数字部分はバージョンによる)
というメタデータが標準で追加されるので、
オプション &lt;kbd&gt;-fflags +bitexact&lt;/kbd&gt; を付けてこの動作を抑制します。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -i input.wav -ac 1 -ar 8000 -acodec pcm_u8 -fflags +bitexact output.wav
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wav-ファイルを-spiffs-へ保存する&quot;&gt;WAV ファイルを SPIFFS へ保存する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.mgo-tec.com/blog-entry-spiffs-uploader-plugin-arduino-esp32.html&quot;&gt;ESP32-WROOM-32 SPIFFS アップローダープラグインの使い方 | mgo-tec電子工作&lt;/a&gt;
に書かれている手順に従い、
&lt;a href=&quot;https://github.com/me-no-dev/arduino-esp32fs-plugin&quot;&gt;Arduino ESP32 filesystem uploader&lt;/a&gt;
を使用して事前に  WAV ファイルを SPIFFS へ保存しておきます。&lt;/p&gt;

&lt;h2 id=&quot;スケッチの書き込み&quot;&gt;スケッチの書き込み&lt;/h2&gt;

&lt;p&gt;以下のスケッチを M5StickC へ書き込みます。
WAVE_FILE_NAME は SPIFFS へ保存した  WAV ファイルのファイル名です。
書き込み後、Aボタン(正面の「M5」ボタン)を押すと WAV ファイルが再生されます。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;M5StickC.h&amp;gt;
#include &amp;quot;FS.h&amp;quot;
#include &amp;quot;SPIFFS.h&amp;quot;

// WAVファイル名
const char WAVE_FILE_NAME[] = &amp;quot;/hoge.wav&amp;quot;;

// スピーカー出力ピンの番号
const uint8_t SPEAKER_PIN = GPIO_NUM_26;
// LOWでLED点灯、HIGHでLED消灯
const uint8_t LED_ON = LOW;
const uint8_t LED_OFF = HIGH;
// 電源ボタンが1秒未満押された
const uint8_t AXP_WAS_PRESSED = 2;

// PWM出力のチャンネル
const uint8_t PWM_CHANNEL = 0;
// PWM出力の分解能(ビット数)
const uint8_t PWM_RESOLUTION = 8;
// PWM出力の周波数
const uint32_t PWM_FREQUENCY = getApbFrequency() / (1U &amp;lt;&amp;lt; PWM_RESOLUTION);
// 音声データのサンプリング周波数(Hz)
const uint32_t SOUND_SAMPLING_RATE = 8000;
// 音声データ再生時の待ち時間(マイクロ秒)
const uint32_t DELAY_INTERVAL = 1000000 / SOUND_SAMPLING_RATE;

// WAVファイルのヘッダー
typedef struct {
    uint32_t riff;              // &amp;quot;RIFF&amp;quot; (0x52494646)
    uint32_t fileSize;          // ファイルサイズ-8
    uint32_t wave;              // &amp;quot;WAVE&amp;quot; (0x57415645)
    uint32_t fmt;               // &amp;quot;fmt &amp;quot; (0x666D7420)
    uint32_t fmtSize;           // fmtチャンクのバイト数
    uint16_t format;            // 音声フォーマット (非圧縮リニアPCMは1)
    uint16_t channels;          // チャンネル数
    uint32_t samplingRate;      // サンプリングレート
    uint32_t avgBytesPerSecond; // 1秒あたりのバイト数の平均
    uint16_t blockAlign;        // ブロックサイズ
    uint16_t bitsPerSample;     // 1サンプルあたりのビット数
    uint32_t data;              // &amp;quot;data&amp;quot; (0x64617461)
    uint32_t dataSize;          // 波形データのバイト数
} wavfileheader_t;
// PCMフォーマット
const uint16_t WAVE_FORMAT_PCM = 0x0001;
// モノラル
const uint16_t WAVE_MONAURAL = 0x0001;

// 音声データ
std::vector&amp;lt;uint8_t&amp;gt; soundData;


// メッセージ出力
void showMessage(const char* message) {
    M5.Lcd.fillScreen(WHITE);
    M5.Lcd.setCursor(5, 30);
    M5.Lcd.setTextFont(4);
    M5.Lcd.setTextColor(BLACK);
    M5.Lcd.print(message);
}

// バイトオーダーを入れ替える
uint32_t reverseByteOrder(uint32_t x) {
    return ((x &amp;lt;&amp;lt; 24 &amp;amp; 0xFF000000U) |
            (x &amp;lt;&amp;lt;  8 &amp;amp; 0x00FF0000U) |
            (x &amp;gt;&amp;gt;  8 &amp;amp; 0x0000FF00U) |
            (x &amp;gt;&amp;gt; 24 &amp;amp; 0x000000FFU));
}

// WAVファイルのヘッダーを検証する
bool validateWavHeader(wavfileheader_t&amp;amp; header) {
    Serial.printf(&amp;quot;riff: 0x%x\n&amp;quot;, header.riff);
    Serial.printf(&amp;quot;wave: 0x%x\n&amp;quot;, header.wave);
    Serial.printf(&amp;quot;fmt : 0x%x\n&amp;quot;, header.fmt);
    Serial.printf(&amp;quot;data: 0x%x\n&amp;quot;, header.data);
    Serial.printf(&amp;quot;format: %d\n&amp;quot;, header.format);
    Serial.printf(&amp;quot;channels: %d\n&amp;quot;, header.channels);
    Serial.printf(&amp;quot;samplingRate: %d\n&amp;quot;, header.samplingRate);
    Serial.printf(&amp;quot;bitsPerSample: %d\n&amp;quot;, header.bitsPerSample);

    return  header.riff             == 0x52494646
            &amp;amp;&amp;amp; header.wave          == 0x57415645
            &amp;amp;&amp;amp; header.fmt           == 0x666D7420
            &amp;amp;&amp;amp; header.data          == 0x64617461
            &amp;amp;&amp;amp; header.format        == WAVE_FORMAT_PCM
            &amp;amp;&amp;amp; header.channels      == WAVE_MONAURAL
            &amp;amp;&amp;amp; header.samplingRate  == SOUND_SAMPLING_RATE
            &amp;amp;&amp;amp; header.bitsPerSample == PWM_RESOLUTION;
}

// WAVファイルを読み込む
void readWavFile(fs::FS&amp;amp; fs, const char* path, std::vector&amp;lt;uint8_t&amp;gt;&amp;amp; data) {
    Serial.printf(&amp;quot;Reading file: %s\n&amp;quot;, path);

    File file = fs.open(path);
    if (!file || file.isDirectory()) {
        Serial.println(&amp;quot;- failed to open file for reading&amp;quot;);
        return;
    }

    // WAVファイルのヘッダー
    wavfileheader_t header;

    // ファイルサイズがヘッダーサイズ以下の場合は終了
    size_t fileSize = file.size();
    if (fileSize &amp;lt;= sizeof(header)) {
        Serial.println(&amp;quot;invalid wave file&amp;quot;);
        return;
    }

    // ヘッダーサイズ分読み込む
    file.read((uint8_t*)&amp;amp;header, sizeof(header));

    // バイトオーダーを入れ替え
    header.riff = reverseByteOrder(header.riff);
    header.wave = reverseByteOrder(header.wave);
    header.fmt  = reverseByteOrder(header.fmt);
    header.data = reverseByteOrder(header.data);

    // ヘッダーのチェック
    if (!validateWavHeader(header)) {
        Serial.println(&amp;quot;invalid wave file header&amp;quot;);
        return;
    }

    // ファイルの読み込み
    while (file.available()) {
        data.push_back(file.read());
    }
}

// 音声データを再生する
void playSound(std::vector&amp;lt;uint8_t&amp;gt;&amp;amp; soundData) {
    for (const auto&amp;amp; level : soundData) {
        ledcWrite(PWM_CHANNEL, level);
        delayMicroseconds(DELAY_INTERVAL);
    }

    ledcWrite(PWM_CHANNEL, 0);
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;SPIFFS WAV&amp;quot;);

    // シリアルモニターの設定
    Serial.begin(115200);

    // スピーカーの設定
    ledcSetup(PWM_CHANNEL, PWM_FREQUENCY, PWM_RESOLUTION);
    ledcAttachPin(SPEAKER_PIN, PWM_CHANNEL);
    ledcWrite(PWM_CHANNEL, 0);

    // LEDの設定
    pinMode(M5_LED, OUTPUT);
    digitalWrite(M5_LED, LED_OFF);

    // SPIFFSの設定
    if (!SPIFFS.begin()) {
        Serial.println(&amp;quot;SPIFFS Mount Failed&amp;quot;);
        return;
    }

    // 音声データを読み込む
    readWavFile(SPIFFS, WAVE_FILE_NAME, soundData);
}

void loop() {
    delay(10);

    // ボタンの状態を更新
    M5.update();

    // Aボタンが押されたら音声データ再生
    if (M5.BtnA.wasPressed()) {
        // LED点灯
        digitalWrite(M5_LED, LED_ON);
        // 音声データ再生
        playSound(soundData);
        // LED消灯
        digitalWrite(M5_LED, LED_OFF);
    }

    // 電源ボタンが押されたらリセット
    if (M5.Axp.GetBtnPress() == AXP_WAS_PRESSED) {
        esp_restart();
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/f03a6569138715d7d46a33e7a4d06e19.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mgo-tec.com/blog-entry-spiffs-uploader-plugin-arduino-esp32.html&quot;&gt;ESP32-WROOM-32 SPIFFS アップローダープラグインの使い方 | mgo-tec電子工作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/espressif/arduino-esp32/blob/master/libraries/SPIFFS/examples/SPIFFS_Test/SPIFFS_Test.ino&quot;&gt;arduino-esp32/SPIFFS_Test.ino at master · espressif/arduino-esp32&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youfit.co.jp/archives/1418&quot;&gt;音ファイル（拡張子：WAVファイル）のデータ構造について&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yatt.hatenablog.jp/entry/20090904/1252078381&quot;&gt;リニアPCMのWAVファイルを読み込む - yattのブログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 07 Jun 2020 20:24:56 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/06/07/m5stickc-speaker-hat%E3%81%A7spiffs%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0wav%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC</category>
        
        <category>M5Stack</category>
        
        <category>ESP32</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>M5StickC + Speaker Hat で音声データを再生する</title>
        <description>&lt;p&gt;M5StickC + Speaker Hat で音声や音楽を再生しようと思ったら
意外と情報が見つからなかったので再生方法をメモしておきます。&lt;/p&gt;

&lt;h2 id=&quot;音声データの変換&quot;&gt;音声データの変換&lt;/h2&gt;

&lt;p&gt;まずは WAV や MP3 など再生したい音声データを
&lt;a href=&quot;http://nn-hokuson.hatenablog.com/entry/2017/09/01/092945&quot;&gt;【Arduino】WAVまたはMP3ファイルを再生する - おもちゃラボ&lt;/a&gt;
に書かれている方法で以下の形式へ変換します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;モノラル&lt;/li&gt;
  &lt;li&gt;サンプリング周波数8000Hz&lt;/li&gt;
  &lt;li&gt;Unsigned 8-bit PCM&lt;/li&gt;
  &lt;li&gt;ヘッダなし&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;配列化&quot;&gt;配列化&lt;/h2&gt;

&lt;p&gt;その後C言語の配列に変換する必要がありますが、
Windows 環境では xxd コマンドがないため
&lt;a href=&quot;https://hello-world.blog.ss-blog.jp/2016-10-16&quot;&gt;バイナリファイルをC言語のデータ配列に変換する：放課後マイコンクラブ：SSブログ&lt;/a&gt;
の「PROGMEM作蔵さん」を使用して変換しました。&lt;/p&gt;

&lt;h2 id=&quot;スケッチへ貼り付けて書き込み&quot;&gt;スケッチへ貼り付けて書き込み&lt;/h2&gt;

&lt;p&gt;配列ができたら以下のスケッチの SOUND_DATA 部分に貼り付け、M5StickC へ書き込みます。
Aボタン(正面の「M5」ボタン)を押すと音声データが再生されます。&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#include &amp;lt;M5StickC.h&amp;gt;

// スピーカー出力ピンの番号
const uint8_t SPEAKER_PIN = GPIO_NUM_26;
// LOWでLED点灯、HIGHでLED消灯
const uint8_t LED_ON = LOW;
const uint8_t LED_OFF = HIGH;

// PWM出力のチャンネル
const uint8_t PWM_CHANNEL = 0;
// PWM出力の分解能
const uint8_t PWM_RESOLUTION = 8;
// PWM出力の周波数
const uint32_t PWM_FREQUENCY = getApbFrequency() / (1U &amp;lt;&amp;lt; PWM_RESOLUTION);
// 音声データのサンプリング周波数(Hz)
const uint32_t SOUND_SAMPLING_RATE = 8000U;

// 音声データ
const uint8_t SOUND_DATA[] PROGMEM = {
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, …
};

// メッセージ出力
void showMessage(char *message) {
    M5.Lcd.fillScreen(TFT_BLACK);
    M5.Lcd.setCursor(5, 30);
    M5.Lcd.setTextFont(4);
    M5.Lcd.print(message);
}

void setup() {
    M5.begin();
    M5.Lcd.setRotation(1);
    showMessage(&amp;quot;Sound&amp;quot;);

    // スピーカーの設定
    ledcSetup(PWM_CHANNEL, PWM_FREQUENCY, PWM_RESOLUTION);
    ledcAttachPin(SPEAKER_PIN, PWM_CHANNEL);
    ledcWrite(PWM_CHANNEL, 0);

    // LEDの設定
    pinMode(M5_LED, OUTPUT);
    digitalWrite(M5_LED, LED_OFF);
}

void playMusic(const uint8_t* music_data, uint32_t sample_rate) {
    uint32_t length = strlen((char*)music_data);
    uint32_t delay_interval = ((uint32_t)1000000U / sample_rate);
    for (int i = 0; i &amp;lt; length; i++) {
        ledcWrite(PWM_CHANNEL, music_data[i]);
        delayMicroseconds(delay_interval);
    }
    ledcWrite(PWM_CHANNEL, 0);
}

void loop() {
    delay(10U);

    // ボタンの状態を更新
    M5.update();

    // ボタンが押された場合の処理
    if (M5.BtnA.wasPressed())
    {
        // LED点灯
        digitalWrite(M5_LED, LED_ON);
        // 音声データ再生
        playMusic(SOUND_DATA, SOUND_SAMPLING_RATE);
        // LED消灯
        digitalWrite(M5_LED, LED_OFF);
    }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/saasan/5ae9fc7ede308cd513e9769c4335c94f.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;playMusic 関数は公式の
&lt;a href=&quot;https://github.com/m5stack/M5StickC/blob/master/examples/Hat/SPEAKER/SPEAKER.ino&quot;&gt;サンプルスケッチ&lt;/a&gt;
のものですが、
そのままでは音声が正常に再生されなかったため
ledcWriteTone から ledcWrite へ変更しています。
(公式のサンプルスケッチが間違ってるとは思わなかったのでここでハマった。)&lt;/p&gt;

&lt;p&gt;今回は短い音声の再生だったためスケッチにそのまま配列として書きましたが、
音声データ部分だけで500行を超えましたし、
配列への変換も面倒なのでファイルから読み込むようにしたいですね。
&lt;a href=&quot;https://lang-ship.com/reference/unofficial/M5StickC/Storage/SPIFFS/&quot;&gt;SPIFFS&lt;/a&gt;
を使えば実現できそう。&lt;/p&gt;

&lt;h2 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/m5stack/M5StickC/blob/master/examples/Hat/SPEAKER/SPEAKER.ino&quot;&gt;M5StickC/SPEAKER.ino at master · m5stack/M5StickC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nn-hokuson.hatenablog.com/entry/2017/09/01/092945&quot;&gt;【Arduino】WAVまたはMP3ファイルを再生する - おもちゃラボ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hello-world.blog.ss-blog.jp/2016-10-16&quot;&gt;バイナリファイルをC言語のデータ配列に変換する：放課後マイコンクラブ：SSブログ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://lang-ship.com/blog/work/esp32-pwm-max/&quot;&gt;ESP32のPWM出力は255が最大じゃなかった – Lang-ship&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wisdom.sakura.ne.jp/system/winapi/media/mm5.html&quot;&gt;PCM の基本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 May 2020 10:59:30 +0900</pubDate>
        <link>https://saasan.github.io/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</link>
        <guid isPermaLink="true">https://saasan.github.io/blog/2020/05/25/m5stickc-speaker-hat%E3%81%A7%E9%9F%B3%E5%A3%B0%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%86%8D%E7%94%9F%E3%81%99%E3%82%8B.html</guid>
        
        <category>M5StickC</category>
        
        <category>M5Stack</category>
        
        <category>ESP32</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
